co chceme sepsat?


file handles
speciální file handles
file attributes
standardní atributy pro unix a windows
extensions
standardní extensions
list of commands


dependence:


speciální file handles <- file handles, file attributes
file handles <- (commands)
commands <- file handles, attributes


takže:
1) “server filesystem model” -> kde řekneme, co jsou to handles, jak se vztahují k serverovému filesystému, 








1. Introduction


1.1 Underlying layer


The protocol was originally designed to run on top of TCP/IP + TLS. However, there are no technical reasons to use different underlying layer, as long as it allows communication in both directions, provides session management, error correction and encryption.
The following description assumes that the underlying layer is an octet stream. Section (XXX) discusses necessary changes for using the protocol over message-oriented connections such as SCTP.


1.2 Basic mode of operation


The protocol recognizes of two kinds of packets: the “command” (client) packets and the “reply” (server) packets. Both kinds consist of a fixed-length header and a variable-length payload of up to 64kB. The payload can have a length of zero.


Server must send one reply packet in reply to each one command packet received from client. It must not send data unless asked to.


Client is allowed to close the connection at any time. Upon recognizing this, server should stop all pending processing. If the connection is terminated and server receives an incomplete command packet, it must ignore it.


2. Data types


The protocol only uses unsigned integral numeric types. In packet and structure descriptions the types are called ‘uintX’, where X specifies the size of the data type in bits. This version of the protocol uses types uint8, uint16, uint32 and uint64.
All numeric types are transmitted in network (big-endian) byte order.


A string type consists of uint16 length, followed by a sequence of length bytes. The sequence represents an Unicode string encoded in a so-called “surrogate-escaped UTF-8”. Strings are not null-terminated - any null character is considered part of the string.
The encoding differs from UTF-8 in that it allows ‘smuggling’ bytes 128 and above as lone surrogate codes U+DC80 through U+DCFF. This is useful when, for example, the server is attempting to send a filename that cannot be converted to Unicode with server’s default character encoding. Instead of failing, the server can encode undecodable bytes in a reversible way. The client then can use the received sequence to assign file handles and manipulate the problematic filename.
Note that a sequence containing smuggled bytes is no longer valid in unmodified UTF-8. Clients that don’t want to bother with the modified encoding should be prepared for possible errors in decoding the UTF-8 sequences.
This encoding cannot reversibly encode undecodable bytes below 128, which can appear in encodings that are not ASCII-compatible.
( XXX “raw-filenames” extension to solve this? and if yes, is it necessary to use the surrogate-UTF?)


3. Packet description


Command packet header is 12 bytes long. Its structure is as follows:
byte 0-3: uint32 command ID 
byte 4-7: uint32 command code (XXX ???)
byte 8-9: uint16 handle ID
byte 10-11: uint16 payload length


Reply packet header is 8 bytes. Its structure is as follows:
byte 0-3: uint32 command ID
byte 4-5: uint16 status code
byte 6-7: uint16 payload length


Command ID is meaningless to server, it only serves to match command packets with their replies. Server’s reply to a command packet will have the same command ID as the original command packet.
It is not an error if two commands use the same Command ID.


***
3. Atomicity and concurrency model


The protocol does not particularly care for concurrent access, and therefore its viability in scenarios requiring this is limited. Atomicity of individual command operations is provided on a best-effort basis: servers should attempt to perform commands atomically where possible, but there is no guarantee and no hard requirement for this.


The protocol supports some operations that are inherently non-atomic, such as recursive deletes and transparently moving files from one filesystem to another. No attempt at atomicity is made in such cases. If an operation is interrupted by an error, server should perform a rollback to such an extent that invoking the same operation again can proceed without error (provided, of course, that the cause of the original error is removed).


File write operations make no guarantee of atomicity. In case of error, they have a “partial write” failure mode.


“Locking” extension allows for better control of concurrent access for scenarios and clients that require this.
***


4. Server directory tree and file handles


All files accessible on the server are part of one virtual directory structure


The server keeps per-connection state information in the form of file handles. Each file handle represents a filesystem path, configurable by client through CMD_ASSIGN commands.
Handles 0xFF00-0xFFFF are special - they do not refer to paths, but instead are reserved for server metainformation. Calling CMD_ASSIGN on those handles is illegal.
(XXX reserve more for extensions?)
For client convenience, handle 0 is preconfigured to the empty path, representing filesystem root. Client is free to reassign this handle as it sees fit.


Server can specify how many handles are available for the client, but it must provide at least 16 handles. The provided handles can only be a contiguous sequence of IDs starting at 0, so if the server is providing N handles, it will be handles 0 to N-1.


4.2 Special file handles


The following special file handles are defined:


HL_EXTENSIONS (0xFF00):
Reading from this handle will retrieve a sequence of uint16-string pairs, which represents a list of extensions available on the server. Each entry consists of an uint16 extension ID, followed by a string containing canonical extension name. Several extensions are described as part of the protocol, and third parties may define their own.


HL_ATTRIBUTES (0xFF01):
Ditto for available file attributes. TODO common description of list format, structures, etc... what i have now sucks bigtime


HL_ATTR_SET (0xFF02):
Contents of this handle represent the set of attributes that are retrieved as part of directory listing. This is represented as a sequence of uint16 attribute IDs. At start of session, this is preconfigured to the default attribute set followed by a preferred attribute set for server’s platform.
The default and preferred sets are described in section about attributes.


5. Commands


5.1 Common error codes


Unless explicitly stated that handle ID is ignored, any command can return BADHANDLE in response to a handle ID outside the range supported by server.
Any command can return SERVFAIL code. This indicates a serious error on the server and in all likelihood it means that the server is not sane enough to continue the session.
Any command that touches disk can return IO (disk I/O error).
Any command can return DENIED (access was denied for this user) or BUSY (access was denied because the resource is in use and server’s operating system doesn’t allow concurrent access). (XXX do we need this?)
Server will return BADCMD in reply to any command that it doesn’t know.


5.2 Basic command set


CMD_PING (0x00)
parameters: none


A testing command. Upon receiving this, server must reply with an OK status code immediately. Handle ID from the command is ignored.


Returns: nothing


CMD_HELLO (0x01)
parameters: uint16 version, string host


Session start command. This must be the very first command the client sends.
Version specifies the highest protocol version the client supports.
Host specifies the hostname to which the client is trying to connect. The server may ignore this field, or decide which of the available directory trees (virtual hosts) to serve based on this value. Client is allowed to leave this field empty.


Returns: welcome structure
uint16 version
uint16 maxhandles
uint32 extension_hash
string platform


version is the highest protocol version the server supports.
maxhandles is the maximum number of file handles available to client.
extension_hash is a hash of extension configuration. (XXX really? and what hash?)
platform is a free-form string with the name of server’s platform. Based on this field, client can make assumptions about filename properties, available file attributes and extensions.


CMD_ASSIGN (0x02)
parameters: string name


Assigns the path name to the supplied handle ID. The server checks whether the name is acceptable as a path on the host system, but does not touch disk.


Returns: nothing
Errors: BADPATH if the path is not acceptable for host system


CMD_STAT (0x03)
parameters: none


Retrieves all available file attributes for the handle.
(XXX what format? default + platform preferred set?)


Returns: attribute structure
Errors: NOTFOUND - when this handle’s path doesn’t exist


CMD_SEEK_READ (0x04)
parameters: uint64 offset, uint16 length


Performs a blocking read from the specified file, starting at ‘offset’.
This is the same as CMD_READ, except that the current file position is first updated to ‘offset’. This happens even if ‘length’ is zero.
See CMD_READ description below for detailed breakdown of read behavior.


Returns: data read, or nothing
Errors: In addition to CMD_READ errors, CMD_SEEK_READ can return the following:
UNSEEKABLE - when used with a special file that doesn’t support the concept of file position (such as sockets, pipes and FIFOs on posix)
BADSEEK - when the offset is beyond end of file and the underlying file/filesystem doesn’t support seeking beyond end of file.


CMD_READ (0x05)
parameters: uint16 length


Performs a blocking read from the specified file, starting at current file position.
If ‘length’ is zero, the call returns with no data.
Otherwise, server attempts to perform the read and returns:
a) zero if the current file position is at or beyond end of file.
b) exactly ‘length’ bytes if there is enough data in the file from the current position to end
c) less than ‘length’ bytes, if
        1. end of file is encountered, i.e. there is less than ‘length’ bytes remaining in the file
        2. an error is encountered
In both cases, the call will return all data that was successfully read, and OK if it stopped at end of file, or error code.
In all cases, current file position is updated so that subsequent CMD_READ calls will pick up where this call left off.


If CMD_READ returns OK and less data than requested, client can assume that it reached end of file. However, if the calls returns full ‘length’ bytes, the client cannot assume that the file is not at end - it might be that there were exactly ‘length’ bytes remaining in the file and a following CMD_READ will return zero (indicating end-of-file condition).


Returns: data read, or nothing
Errors:
NOTFOUND - when this handle’s path doesn’t exist
NOTFILE - when attempting to read from a directory


CMD_SEEK_WRITE (0x06)
parameters: uint64 offset, uint16 length, ‘length’ bytes of data


Performs a blocking file write starting at ‘offset’.
This is the same as CMD_WRITE, except the current file position is first updated to ‘offset’. This happens even when ‘length’ is zero.
See CMD_WRITE description below for detailed breakdown of write behavior.


On systems that support this feature, ‘offset’ can point beyond end of file. When data is written to this position (either from this call, or, if ‘length’ is zero, from subsequent CMD_WRITE), the file is automatically enlarged and padded with null bytes from its original end to ‘offset’. (where possible, this should be implemented as a sparse file.)
If the resulting file would be bigger than maximum allowed file size, or fill all available disk space, it is left unchanged and file position stays at ‘offset’.


Returns: uint16 length of data successfully written.
Errors: in addition to CMD_WRITE errors, CMD_SEEK_WRITE can return the following:
UNSEEKABLE - when used with a special file that doesn’t support the concept of file position BADSEEK - when the offset is beyond end of file and the underlying file/filesystem doesn’t support seeking beyond end of file.
TOOBIG - when the offset is beyond maximum allowed file size
DEVFULL - when the offset is beyond end of file and the resulting file would overflow available disk space


CMD_WRITE (0x07)
parameters: uint16 length, ‘length’ bytes of data


Performs a blocking file write starting at current file position.
If the file does not exist, it is created. Otherwise writing works pretty much as you’d expect: data starting at current position are overwritten by the supplied data, and if the file is not big enough, it grows to accomodate all supplied data.
The current file position is updated to point after the newly written data, so that a subsequent call to CMD_WRITE will continue where this one left off.
If no error occurs, writes all supplied data.


Returns: uint16 length of data actually written (if this is less than ‘length’, it indicates an error)
Errors:
TOOBIG - when the file size reaches maximum file size limit
DEVFULL - when no more data can be written to the underlying device
NOTFILE - when attempting to write to a directory
BADFILE - when attempting to write to a special file that doesn’t support writing


CMD_APPEND (0x08)
parameters: uint16 length, ‘length’ bytes of data


Performs a blocking file write starting at end of file.
This is the same as CMD_SEEK_WRITE with ‘offset’ set to file size. See description of CMD_WRITE and CMD_SEEK_WRITE above for details on behavior.


Returns: uint16 length of data actually written
Errors: same as CMD_SEEK_WRITE


CMD_DELETE (0x09)
Parameters: uint8 recursive


Deletes a file or a directory. If deleting a directory, ‘recursive’ parameter must be specified: value 0x01 means that contents of the directory should be recursively deleted as well, any other value means that server should return an error if the directory is not empty.
If deleting a file, value of ‘recursive’ is ignored. (XXX force 0 to persuade “lazy” clients to not set 1 on everything?)
If the path under the provided handle doesn’t exist, CMD_DELETE returns OK.


Recursive deletion works by traversing the directory tree depth-first, deleting files as it finds them and removing directories when it leaves them. Multiple errors can occur during this process; the server should note the errors and continue to delete as much as possible, then return a generic ERROR code and let the client sort out the rest.


On systems that support symbolic links, the link is never traversed. Delete on the link removes the link, not the file it is pointing to. Recursive delete always considers links to be files and if the link target is a directory, it must not descend into it.


Using recursive delete is inherently dangerous, because there is no way for the client to stop the operation in progress. Clients should make this clear to the user and attempt to do some preliminary checking, such as counting files that are actually going to be deleted and presenting this information to the user.
(XXX should we even allow it? maybe it’s better in some utility extension?)


Returns: nothing
Errors:
NOTEMPTY - when the path refers to a directory which is not empty, and value of ‘recursive’ is other than 1
NOTDIR - when the path refers to a file and ‘recursive’ is 1
ERROR - if errors occurred with recursive delete


CMD_RENAME
Parameters: string newname


Renames the file under the current handle to a new name. If successful, the handle is modified to point to the new file name.
If newname points to an existing directory, the operation fails. Client must ensure that either the directory is removed, or that newname is a full path including filename, whichever is appropriate for the operation.
If current handle points to a file and newname refers to an existing file, it is overwritten. If current handle points to a directory, the operation fails and client must make sure to remove the target file explicitly.

The move operation can cross filesystem boundaries on the server. The server must make sure that this is transparent to the client. This means that the server must implement recursive directory copy

Returns: nothing
Errors: NOTFOUND - when this handle’s path doesn’t exist


CMD_COPY
Parameters: string newname


Copies the f


CMD_READDIR_START


CMD_READDIR


CMD_MKDIR
