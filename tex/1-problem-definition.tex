% vim: tw=110:fo=an1lt

\chapter{Problem Definition}

In this chapter, we present an overview of the problem area and a description of what exactly we are solving.
It should also serve as an introduction for readers unfamiliar with the topic, providing explanations of terms
that we are using throughout this work.


\section{Files and filesystems}

Most modern operating systems share a common idea of what constitutes a filesystem. It is a collection of {\it
files}, which are opaque strings of binary data. Individual files are referenced through a hierarchical
tree-like structure of {\it directories}.  You can identify any file or directory by its {\it path}, which is
a string of entry names delimited by path separator characters\footnotemark[1]. You follow the (absolute) path
by starting at the root directory and always descending into the directory named by the next path element,
until the last element is remaining, naming the target entry.

We want to be able to publish one or more subtrees of the filesystem on one computer, and access this part of
the structure from another computer over a network.


\section{Protocols}

A protocol, simply put, is a communication script for two or more parties. It describes the conversation
structure, semantics and syntax of messages. Here is an overview of several issues that must be solved by
every protocol.


\subsection{Sessions}

The most basic "protocol" imaginable is one computer just firing data packets at another, silently hoping that
the other will reassemble and understand them. We could, in theory, use this sort of protocol for transfering
files, but it is obviously very impractical. All but the most basic protocols will first establish a session,
in order to have a context for further communication. Extent of the session can vary, from simply marking
a collection of packets as belonging together, to providing ordered delivery, to authenticating parties and
encrypting transmitted data.

Basic session functionality is often provided by the transport layer, specifically the Transmission Control
Protocol (TCP). This allows the communicating parties to establish a two-way stream of octets, with
reliability, ordered delivery and flow control. Unless noted otherwise, protocols described in this work are
built on top of TCP.


\subsection{Encoding}

Protocols consist of messages, which must be encoded for over-the-wire transfer. There are two main ways to do
this: either as human-readable text, or as custom binary data.

\subsubsection{Text-based protocols}

In text-based protocols, each message is a string of words and/or numbers, nowadays usually encoded as ASCII
or UTF-8. Many such protocols also use line separator characters to delimit messages. The main advantage of
this approach is that it is readable (and writable) by humans without specialized debugging tools - for
instance, it is possible to communicate with the other party "by hand", without software implementing the
protocol. Historically, there was also the fact that two communicating systems only had to agree on text
encoding, and not about in-memory format of numbers or other data structures.

Drawbacks include overhead of text encoding, both in terms of size and processing time spent encoding and
decoding the textual representation. Another problem is that lengths of message fields are not fixed, so
parsing and framing messages is more difficult.

\subsubsection{Binary protocols}

The alternative to text-based messages is using a format similar to in-memory encoding of data. Each message
can be described by, and parsed as, a C struct\footnotemark[2]. This results in shorter messages and simpler
encoding. If the in-memory encoding is the same as in the protocol, encoding and decoding can even be skipped
completely. Parsing and framing is trivial - every kind of message can either have a fixed number of
fixed-size fields, or it can have a fixed-size part describing lengths of all variable-size fields.

Care must be taken when communicating between systems that differ in endianness.  The protocol either has to
prescribe the byte order, or it must provide means for the parties to negotiate.

Unlike text-based protocols, debugging is not straightforward, humans require specialized tools that convert
the binary messages to understandable text.


\subsection{Roles}

We recognize two basic roles for communicating parties: {\it client} and {\it server}. Client is the party
that sends requests - specifies what is to be done - and server's task is to fulfil the requests and report on
results.

Most protocols are modelled as client-server, with roles of the parties fixed in advance. Typically, the
server is listening for incoming connections and clients connect at their convenience. In a peer-to-peer
model, after establishing the connection, parties can act as both clients and servers at the same time,
sending requests to each other.

In this work, we use the following convention: a {\it server} will be the computer that contains a "master
copy" of a filesystem, and publishes a subtree of this filesystem on the network. A {\it client} is the
computer that wants to manipulate this published tree using the protocol.


%%%

\section{Capabilities of a file transfer protocol}

\subsection{Identifying files}

In order to accomplish anything useful with a protocol, there must be a way to specify on which file you want
to operate. This alone poses a number of issues that must be resolved.

The first question is whether all specified paths are absolute, relative to a fixed path, or relative to the
session's current directory.

TODO

\subsection{Download}

Downloading, i.e. transfering files from server to client, is arguably the most basic capability provided by
a file transfer protocol. Client will request a file and server will respond by sending a binary stream of the
file's contents. Failure modes are obvious: the identifier does not point to a file; file exists but cannot be
read; or this client does not have permission to access the file.

In basic form of download, the server will send full contents of the file as a continuous stream, possibly
preceded by length of the stream. However, it is often more useful to specify a range for reading. This allows
resuming of interrupted downloads, seeking in media streams and the like. It is also very useful if theclient
wants to implement filesystem-like behavior over the protocol.

A general-purpose protocol will treat files as opaque streams. However, in a specialized protocol, it might be
useful to understand structure of the file. This can allow the client to e.g. query contents of the file as
a database, download only thumbnail or embedded metadata etc.

\subsection{Upload}

Transfering from client to server is more complicated. In addition to checking for permissions, the server
must ensure that there is enough disk space, resolve issues with overwriting existing files, as well as
gracefully handle concurrent modifications. There might also be issues with missing path components - trying
to create file in a directory that does not exist. This results in many new failure modes that must be
expressed in the protocol. However, at this level, it is sufficient to add new error codes, or specify that
a single error code covers many different types of failure.

\subsection{Directories}

Although it might be tempting to handle directories as a special case of files, directories are very
different. Where files are opaque blobs, directories are inherently structured, so the protocol must represent
an API for manipulating the structure. A general-purpose protocol should provide at least the following
operations:

\begin{itemize}
	\item list contents of directory
	\item create file/directory
	\item delete file/directory
	\item rename a directory entry
\end{itemize}

\subsection{Filenames}

Different platforms have different conventions for filenames and paths. Some characters might be invalid in
file and path names, lengths of path components or the total length of path might be limited. Protocols should
either abstract away the differences (an inherently difficult problem), provide means to query platform
limitations, or at least acknowledge failure modes for path names and note that they are platform-dependent.

Another problem is correspondence between directory listings and results of operations. On Windows, filenames
are not case-sensitive, so creating file "foo" will fail if the directory already contains file "FOO".
Mac~OS~X normalizes unicode representations of filenames, which can mean that a newly created file will not
appear in subsequent directory listing, if the chosen filename was not in the corresponding normalized form.

\subsection{Filename character encoding}

One place where a file transfer protocol cannot avoid character encoding issues is in path specifiers and
directory entry names. The problem is that different systems have different conventions for filename encoding.
A protocol could specify that filenames are transfered as "plain data", but this would only push the problem
down to individual implementers. A better solution is to either prescribe or negotiate a transfer encoding,
and then transcode filenames in client and server software.

Newer filesystems enforce that a filename is a valid Unicode string, but on many widely used filesystems,
filename can be an arbitrary string of bytes\footnotemark[3]. In effect, a filesystem can store names that
cannot be properly decoded in the system's character set. This presents a problem for the transcoding process.
An obvious solution is to ignore invalid filenames, but that is arguably not very useful. It is seemingly
better to use replacement characters for the undecodable sequences, but in practice, this does not help very
much, as this way of encoding is not roundtrip-safe. The client can get a listing that contains invalid
filenames, but cannot specify them, because files with the "fixed" names do not actually exist on the server.
Moreover, it is impossible for the client to tell apart invalid filenames from valid ones that happen to
contain the replacement characters, unless the replacement characters are forbidden in valid names.

\subsection{Renaming and moving}




%%%

\footnotetext[1]{On UNIX-like systems, the path separator is a forward-slash, '/'. Windows recognizes both
forward-slash and a backslash, but backslash is used more commonly. Nevertheless, we will be using
forward-slash as a path separator everywhere.}

\footnotetext[2]{This does not mean that you can create a message by dumping the memory representation of
a corresponding C struct directly. On modern systems, fields of a struct will be memory-aligned and will
contain some amount of padding. This can differ between systems, compilers, and can even depend on particular
compiler flags.}

\footnotemark[3]{Unless the byte represents a forbidden character, e.g. forward-slash or null byte on UNIX,
shell expansion characters on Windows etc.}
