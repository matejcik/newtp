% vim: tw=110:fo=n1lt:nosmartindent

\chapter{Design of the new protocol}

We have developed a new file transfer protocol called NewTP (as a play on FTP, the original file transfer
protocol). This chapter describes the design decisions that went into the development, how the protocol
operates and what features it provides. We also describe how the extension mechanism works and define several
extensions.

%%

\section{Overview}

NewTP is a binary application protocol running on an encrypted channel with ordered and reliable delivery. It
is designed with TCP + TLS in mind; for this version, use of TLS 1.2 or later is mandatory. Communication is
split into packets with a fixed-length header and at most 64 kB of data. Client initiates all traffic. For
every client request packet, server must send exactly one reply packet, and it must send the replies in the
order in which it received the requests.

After an initial handshake, client must authenticate itself using the SASL protocol~\cite{rfc4422}. Where
appropriate, anonymous authentication mechanism will be available. A conforming implementation must support at
least anonymous and password-based authentication.\footnote{That is, {\tt ANONYMOUS} and {\tt PLAIN} SASL
mechanisms.}

Once the session is established, client sends requests and receives replies in a common format. Every command
operates on an object refered to by a file handle. Before use, client must set up the file handle by assigning
a path string to it. Requests specify an arbitrary ID that is repeated in the reply; although this version of
the protocol does not allow it, future revisions might let the server reorder replies, in which case the
request ID will be used to match replies to corresponding requests.

Core NewTP command set consists of ranged read, ranged write with implicit file creation, truncate operation,
directory listing that includes selected metadata attributes, creating directories, delete and rename/move
operations, metadata querying and manipulation. Additional commands can be added through an extension
mechanism without changing the protocol.

%%

\section{Design decisions}

The protocol is intended as a lightweight file transfer protocol with some filesystem-like features. We wanted
to limit its feature set for ease of implementation, provide reasonable performance on high-latency networks,
ensure cross-platform interoperability, and make the protocol secure by default.

%

\subsection{Supported scenarios}

NewTP is designed with three main use cases in mind.

%

\subsubsection{Local fileserver}

In this scenario, the NewTP server is placed on a private local network or a VPN and provides a shared
document and multimedia store for its users. The network is considered a trusted environment, and the server
assumes that clients allowed to connect to the network are automatically entitled to access the document
store.  Encryption is not essential and authentication is completely unnecessary. Filesystem-like features are
desirable for operating system integration, but advanced locking and conflict resolution features are not
required, because conflicts will usually be resolved on the human level. This is the case for file servers or
media centers on home networks. Users in this scenario don't necessarily have technical background, so neither
the protocol nor its implementations should place any barriers to ease of use.

%

\subsubsection{Temporary share on a public network}

Users connected to the same network want to quickly exchange files. One of them sets up a NewTP server on
their computer, the others connect to it and download the published files or upload their own data. After all
transfers are done, the server is shut down. The network is assumed to be untrusted -- it might be an open WiFi
in a restaurant or a shared building-wide LAN -- so we require encryption, authentication and MitM protection.
However, the users are assumed to have a communication side-channel, such as close physical proximity, so
there is no need for any sort of PKI. The emphasis is on the ability to set up a server quickly, without
complicated supporting infrastructure. Ideally, both server and client software are implemented as portable
executables that the users can download and run with minimum of configuration. Filesystem-like features are
not required, because the users only need upload, download and directory manipulation capabilities.

%

\subsubsection{Shared Internet fileserver}

A web hosting or cloud storage provider sets up a NewTP server connected to the Internet. Clients of the
provider are issued credentials and use the NewTP protocol to access their files. Obviously, encryption and
MitM protection is required. However, in this scenario, it is more difficult to verify authenticity of the
server. Its certificate must either be verifiable through a PKI, or a through a side-channel such as physical
mail.  Implementations should also check for certificate changes.

A single server will be serving multiple users, so the protocol must provide user accounts and the
implementation will publish different parts of the filesystem based on which user account is authenticated.
Users will be using both dedicated NewTP clients and operating system integration, so filesystem-like
features, although not strictly required, are strongly desirable.

%

\subsection{Simplicity}

Simplicity means different things to different people and in different contexts. In case of NewTP, we want to
ensure that the protocol is simple to implement and use properly. The core feature set is small and
variability of commands is limited. Individual commands mostly correspond to how the operating system works
with filesystems, so each command can usually be implemented with one or two system calls on the server. On
the client, it is easy to replicate common file operations with calls over the network. In difficult cases, we
opt for less complex solutions that work well for our supported scenarios, even if they do not perfectly cover
corner cases.

Simplicity is also the reason for choosing TCP as the transport layer. This way, the protocol does not need to
concern itself with lost or out-of-order packets.

%

\subsection{Secure by default}

Protocols designed before the rise of Internet usually provide encryption as an optional feature. This leads
to widespread practice of using unencrypted connections on insecure public networks. We want to avoid this
practice with NewTP. Therefore, the protocol mandates use of TLS 1.2 or later for every connection.
Furthermore, we recommend that implementations use the highest available version of TLS at a given time, and
disable weak ciphersuites.

Especially in the ``local fileserver'' and ``temporary share'' scenarios, it is unrealistic to expect that
users would obtain a certificate from a trusted certificate authority, much less roll their own.
Implementations must allow self-signed certificates by default, and for ease of use, server applications
should generate their own certificates automatically. To ensure that attacker does not impersonate
a legitimate server with a brand new self-signed certificate, clients should remember certificates on first
connection and warn the user if the certificate has changed.\footnote{This practice is known as {\it
certificate pinning}.}

We attempted to design NewTP so that implementing it does not easily lead to buffer overflows.  Packet size is
limited to 64 kB, so every packet can fit into a fixed-size buffer. The protocol is binary and most packet
structures have a predefined size. Strings are not null-terminated, so the implementation is forced to use the
corresponding length field. Same is true for lists of structs. Where possible, length information is not
duplicated so implementations cannot be fooled by a mismatch. Simplicity of the protocol also means that the
client can't easily tie up disproportionately huge amounts of server processing power with a small number
of~requests.

%

\subsection{Low latency}

Given that the protocol is using TLS on top of TCP, establishing a connection takes a nontrivial amount of
time. This is even more true on high-latency networks like GPRS/EDGE. We want to make operation on such
networks as painless as possible. That means good support for interleaving of operations on a single
connection, and reducing size of protocol messages.

The choice of a binary protocol results in smaller messages. The short maximum packet length means that in the
ideal case, after a new operation is inserted into the outgoing stream, the client downloads at most 64 kB of
data before receiving a response for the newly inserted operation. In practice, clients on high-latency
networks will batch requests, so that when the new operation is inserted, it has to wait before the whole
preceding batch is processed. However, there is room for implementations to perform flow control and send
batched messages only as fast as they can receive responses, in which case it is possible to insert commands
midway through.

This sort of interleaving rules out long operations, which is helpful even on fast networks. It means that it
is easy to implement a responsive filesystem emulation on top of NewTP.

To make the amount of transfered data even smaller, implementers may choose to enable TLS compression. Be
advised, though, that encryption and compression interact in nontrivial ways TODO

Transfer overhead works out to 24 bytes (TODO calculate based on actual packet!!!) per 64 kB when using
maximum possible packet size. To put this in perspective, when downloading 2 GB of data at top speed, protocol
overhead will consume additional 786 kB.  This is perfectly acceptable.

%

\subsection{Authentication is optional}

In the ``local fileserver'' scenario, we don't want the clients to authenticate. In the ``temporary share'',
the authentication is supposed to be short and simple, probably based on a passphrase. In the ``Internet
fileserver'' scenario, strongest possible authentication is required, possibly including client certificates
or two-factor authentication.

We decided to implement authentication through the SASL protocol. This allows us to use a wide range of
authentication mechanisms, ranging from anonymous access, to plaintext usernames and password, to digest-based
authentication. Also, with SASL, new authentication mechanisms can be supported by implementations without
changing the NewTP protocol. Reusing an existing technology (SASL is implemented by a number of widely
available libraries) also reduces work for implementers.

The fact that SASL supports anonymous authentication allows us to make the SASL process mandatory, while still
technically keeping authentication optional. This again simplifies the protocol.

%

\subsection{Concurrency is out of scope}

NewTP is intended to service use cases with minimal interactions between users and negligible amounts of
conflicts. Because of that, we decided not to put any locking mechanisms into the protocol. Locking is
a decidedly complex problem in itself, and it is not a problem that NewTP is trying to solve.

We take concurrency issues into consideration and make reasonable attempts to prevent or solve them. We expect
that locking mechanisms could be implemented as protocol extensions, either by third parties or in a future
revision of the protocol. In general, however, we consider reliable concurrency to be out of scope, and
recommend using a different protocol for scenarios that require it.

%

\subsection{Caching policy}

In this version of the protocol, clients are fully responsible for managing their caches.  Depending on the
application, a client should periodically check freshness of relevant data.  For filesystem emulation, clients
should check cache freshness every time a file is opened, and perform server write when the file is closed.
In addition, it is advisable to refresh directory cache at reasonable intervals, e.g., once a minute.  (XXX
really?)

We considered adding a mechanism through which the server could request cache invalidation. However, since all
traffic is initiated by the client, server has no means to send unsolicited updates. Adding this would
complicate client implementations and we did not want that. Alternately, clients could register watched items
and then use a single command to poll their status periodically. We did not make this a part of the core
protocol, but a future revision might introduce an extension with this functionality.

%

\subsection{Non-idempotent operations}

Since native locking is not part of the protocol, we make an attempt to minimize problems with directory-based
locking and mitigate potential issues with non-idempotent operations. To this end, we have designed
a ``Replay'' extension. After establishing a session and authenticating, the client can ask for a unique
session token. If the connection is lost, the client can reconnect, and after a successful authentication, ask
for a replay of the session identified by that token. The server will reply with results for the last few
non-idempotent operations recorded under the provided token. If the session is still alive on the server, it
will be terminated to prevent late delivery of further commands. This way the client can resume after the last
command that was successfully received by the server.

Security of this extension is ensured by using tokens that are long enough to prevent guessing, and only
providing the replay to the same user account.

%%

\section{Building blocks}

This section describes various technical details pertaining to design and implementation of NewTP.

%

\subsection{Packet format notation}

Packets are described in a C-style format, data type preceding field name. Various packets use data types
defined as follows. All numeric fields are stored in network byte order (big-endian).

\def\ttitem#1{ \item[\ttfamily #1] }
\begin{description}[leftmargin=1.7cm,style=sameline]
	\ttitem{byte} An 8-bit value (octet). Bytes represent command codes, result codes and other fields
		where the value is one of a fixed set of possibilities. The values are written out in
		hexadecimal notation, e.g., {\tt 0x07}.
	\ttitem{uint16} Unsigned 16-bit integer
	\ttitem{uint32} Unsigned 32-bit integer
	\ttitem{uint64} Unsigned 64-bit integer
	\ttitem{time\_t} Unsigned 64-bit integer, representing time in microseconds since the start of UNIX
		epoch (January 1, 1970, 0:00:00 UTC)
	\ttitem{string} Byte sequence of arbitrary length, representing a Unicode string encoded in UTF-8.
		The field is not null-terminated. Length is not part of the {\tt string} field, a separate
		{\tt uint16} length information must precede it.
	\ttitem{data} Byte sequence of arbitrary length, representing arbitrary data. Same as {\tt string},
		length must be specified separately.
\end{description}

%

\subsection{Path string encoding}

All filenames and path strings, expressed as {\tt string} fields in packet descriptions, must be encoded as
UTF-8. Clients and servers must perform transcoding from system-native filename encoding to UTF-8 and back.

To support filenames that are undecodable in the system encoding, NewTP uses a roundtrip-safe encoding scheme
described in PEP~383~\cite{pep383}. In this scheme, an undecodable byte {\tt 0x80}--{\tt 0xFF} is converted to
a lone surrogate codepoint {\tt U+DC80}--{\tt U+DCFF}, which is then encoded to a 3-byte sequence by the UTF-8
algorithm. Upon receiving the string, reverse conversion or implementation-defined handling of the string is
performed.

Surrogates are codepoints reserved for UTF-16 encoding of codepoints above the Basic Multilingual Plane. They
are only valid as pairs in UTF-16, and not valid in UTF-8 at all. Therefore, a valid encoding cannot produce
a string which contains a lone surrogate codepoint, so there are no conflicts with this encoding scheme. Note
that this means that a string using this encoding scheme is not valid UTF-8. Implementations must be prepared
to handle potential UTF-8 decoding errors.

This encoding scheme does not cover all cases. Notably, in some encodings, bytes {\tt 0x00} through {\tt 0x7F}
can be parts of undecodable sequences. These are not supported for security reasons: it might be possible to
``smuggle in'' ASCII sequences such as `{\tt /..}', thus opening a new attack surface that must be checked by
implementations. See PEP~383~\cite{pep383} for full discussion. In NewTP, such bytes are instead to be
replaced by the Unicode replacement character {\tt U+FFFD}.

Also note that certain encodings, such as Big5, cannot be roundtrip-safely decoded to Unicode, because
multiple byte sequences map to the same Unicode codepoint. These are not supported by the core protocol.

%

\subsection{Path strings and file handles}
\label{ssec:paths}

Paths and files in NewTP are referred to through file handles. The {\tt ASSIGN} command assigns a path string
to a file handle, and subsequent commands use the file handle as an argument, instead of the path string. The
purpose of this is to limit repeating of the potentially long path string.

Path strings are absolute and use the slash character (`{\tt /}') to separate path elements. Empty path
elements, path elements `{\tt .}' and `{\tt ..}' must not be part of the path. Directory listing returns names
without full paths, and an absolute path name is constructed by combining directory path, slash, and entry
name from the listing. Empty path string is allowed and refers to root of the published filesystem. Combining
empty path with a slash and a root entry name results in path with a leading slash -- therefore, leading slash
is mandatory. Trailing slash is forbidden; in particular, path string ``{\tt /}'' does not refer to the root
directory and is invalid.

File handle ID is specified as a 16-bit unsigned integer. That means that at most 65536 handles are available
to the client. Servers should provide as many handles as they can. At session initiation, server informs the
client about how many handles are available; these must be consecutive handles numbered 0--$({\tt max\_handles}
- 1)$. A conforming server must provide at least 16 handles. When the session start, every available handle is
set to empty path.

File handles do not necessarily refer to valid filesystem objects -- for example, to create a new directory,
the client assigns the new path to a file handle and then issues a {\tt MAKEDIR} command on that handle.
A file handle does not become invalid when the object it is pointing to is removed, and it does not follow
externally moved files.\footnote{Although as a side-effect, the {\tt RENAME} command updates the file handle
with the new path.}

We wanted to avoid the necessity to open a file before writing, and the complexity associated with managing
``persistent'' open-file handles on the server. This means that several common POSIX usage patterns are not
directly supported: writing to a deleted or moved file recreates the original name instead of continuing to
write to the new location (or to the ``ghost'' version). These usage patterns can be emulated on the client if
necessary; replicating the POSIX semantics in concurrent scenarios is out of scope for NewTP.

%

\subsection{Metadata}

We define a set of basic attributes known about directory entries: entry type, size, creation time,
modification time, access rights etc. Each item is assigned a name, data type and a code. Recognized
attributes are listed in table~\ref{table:attributes}.

When requesting directory listing, the client specifies a sequence of codes, and specified metadata is
returned as part of each entry in the listing. Requested attributes from {\tt STAT} are specified in the same
way. Filesystem-like clients will request the full list, clients that want to save bandwidth can only ask for
attributes they are interested in.  Note that the full list is relatively long: three time fields and a size
field add up to 32 bytes, which is often longer than the entry name.

The {\tt SETATTR} call takes an attribute code and its new value. Only some attributes can be set, those are
marked as ``writable'' in the table. However, the fact that an attribute is writable does not mean that the
client has permission to set it.

Extended attributes and ACLs are not supported in the core protocol, but support can be added via extensions.
Extensions can also provide new attribute codes.

\begin{table}[p]
\begin{center}

\def\tline#1#2#3{
{\ttfamily #1} & {\ttfamily #2} & {\ttfamily #3}
}
\begin{tabular}{|lllcp{6cm}|}
	\hline
	Code & Name & Type & Writable & Value \\
	\hline
	\tline{0x00}{type}{byte} & No &
		Directory entry type: \newline
		{\tt 0x01} -- File \newline
		{\tt 0x02} -- Directory \newline
		{\tt 0x00} -- Other (e.g., device node) \newline
		{\tt 0xFF} -- Error entry
		\\
	\tline{0x01}{rights}{byte} & No &
		Bit mask of simplified access rights for~the current user account:\newline
		{\tt 0x01} -- Read permission \newline
		{\tt 0x02} -- Write permission \newline
		{\tt 0x03} -- Read and write permission
		\\
	\tline{0x03}{size}{uint64} & No & File size in bytes \\
	\tline{0x04}{device\_id}{uint32} & No &
		Arbitrary ID of logical device on which this entry resides.
		Entries within the same filesystem will have the same {\tt device\_id}
		and entries on different filesystmes will differ. No other guarantees
		are provided about the value.
		\\
	\tline{0x05}{links}{uint32} & No & Number of hard links to this entry \\
	\tline{0x06}{time\_access}{time\_t} & Yes & Last accessed time \\
	\tline{0x07}{time\_modified}{time\_t} & Yes & Last modification time \\

	\hline
	\multicolumn{5}{|c|}{\textit{POSIX-specific attributes}} \\
	\hline

	\tline{0x10}{posix\_mode}{uint32} & No &
		File type and permissions as expressed in the {\tt st\_mode} field
		of {\tt struct stat}.\newline
		TODO split type and permissions into separate fields?
		\\
	\tline{0x11}{time\_ctime}{time\_t} & Yes & POSIX {\tt ctime} \\
	\tline{0x12}{uid}{uint32} & Yes & User ID of owner \\
	\tline{0x13}{gid}{uint32} & Yes & Group ID of owner \\

	\hline
	\multicolumn{5}{|c|}{\textit{Windows-specific attributes}} \\
	\hline

	\tline{0x20}{attributes}{uint32} & Yes & Windows file attributes \\
	\tline{0x21}{time\_created}{time\_t} & Yes & Entry creation time \\

	\hline
\end{tabular}

\end{center}
\caption{Attribute codes, types and values}
\label{table:attributes}
\end{table}

%

\subsection{Extension mechanism}
\label{ssec:extensions}

At session intialization, server sends a list of available extensions. Each extension is identified by a name,
which must be unique, and an extension code, which can be dynamically assigned by the server. That means that
the same extension can have different codes on different servers, or even between one session and another.

Session code {\tt 0x00} is reserved for core protocol commands and must not be used in the extension list.
Session codes {\tt 0x01}--{\tt 0x30} are reserved for standard extensions. Standard extensions will be
mentioned in the extension list, but their code is fixed and guaranteed to be the same on all implementations.
Server must not allocate extension codes in this range.

\begin{samepage}
Server sends the extension list as a sequence of fields in the following format:
\begin{description}[parsep=1pt]
	\ttitem{byte extension\_code} \hfill \\
		Extension code
	\ttitem{uint16 extension\_name\_len} \hfill \\
		Length of {\tt extension\_name}
	\ttitem{string extension\_name} \hfill \\
		Name of the extension
\end{description}
\end{samepage}

Extensions can define new protocol commands and result codes, which are then referred to by the extension
code. Extensions can also add new file attributes. Attribute codes do not use the extension code, so extension
authors must ensure that their attribute codes do not conflict with another extension. Extensions may not modify
existing commands or replies.

%%

\section{Communication scheme}

After establishing the TCP connection and successful TLS handshake, the client starts session initialization,
through which it agrees on a common version with the server. If the session was initialized successfully,
client starts the SASL authentication process. If that is successful, client can start sending commands.

Client can disconnect at any time. If the server detects client disconnect, it destroys all associated state,
except for replay cache described in the Replay extension. Unprocessed commands are discarded and long-running
operations in progress are aborted.

%

\subsection{Framing}

Every packet contains a field {\tt uint16 length}, usually denoted ``Length of payload''. This field contains
total length, in bytes, of rest of the packet contents combined. Fields up to and including the {\tt length}
field form the packet {\it header}, which must have a fixed length. Fields after the {\tt length} field form
the packet {\it payload}. After encountering the {\tt length} field, an implementation should retrieve exactly
that many bytes from the data stream to process the whole packet. If the packet is discarded, the
implementation can resume parsing the data stream at that position and safely find the start of the next
packet.

Implementations must check that contents of the payload do not stretch beyond the end of the packet. Notably,
if the payload contains variable-length fields with size specified inline, these must fit inside the packet.
But even if the implementation only expects fixed-length fields, it must check whether the packet is long
enough to contain them. If the expected or calculated length of payload exceeds {\tt length}, the packet is
malformed and should be discarded.\footnote{If the server discards a packet, it must inform the client.} If
the expected or calculated length of payload is smaller than {\tt length}, the implementation must ignore the
remaining data -- these may contain fields that the implementation does not understand.

Only the payload and not the packet header is framed through the {\tt length} field. We assume that if
a communicating party does not understand the fixed-format header, the difference in protocol versions is too
big to allow any sort of meaningful communication anyway.

%

\subsection{Session initalization}

\begin{samepage}
After the TLS session is established, client introduces itself with the following packet:
\begin{description}[parsep=1pt]
	\ttitem{string newtp} \hfill \\
		Fixed ASCII string ``{\tt NewTP}''
	\ttitem{uint16 version} \hfill \\
		Protocol version
	\ttitem{uint16 length} \hfill \\
		Length of payload (in this case, 0)
\end{description}

Protocol version is 1. We specify the payload length for extensibility: in a future version, client might be
sending more info in the initial packet. In version 1, only the version number is sent.
\end{samepage}

\begin{samepage}
Server replies with the following packet:
\begin{description}[parsep=1pt]
	\ttitem{string newtp} \hfill \\
		Fixed ASCII string ``{\tt NewTP}''
	\ttitem{uint16 version} \hfill \\
		Protocol version.
	\ttitem{uint16 length} \hfill \\
		Length of payload
	\ttitem{uint16 max\_handles} \hfill \\
		Number of available file handles
	\ttitem{uint16 max\_opendirs} \hfill \\
		Number of directories available for simultaneous listing
	\ttitem{uint16 platform\_len} \hfill \\
		Length of {\tt platform}
	\ttitem{string platform} \hfill \\
		Platform string
	\ttitem{uint16 authstr\_len} \hfill \\
		Length of {\tt authstr}
	\ttitem{string authstr} \hfill \\
		List of supported SASL authentication mechanisms, separated by ASCII spaces ({\tt 0x20})
	\ttitem{uint16 num\_extensions} \hfill \\
		Number of extension fields TODO number or length?
	\ttitem{data extensions} \hfill \\
		Extension fields
\end{description}
\end{samepage}

Platform string can be ``{\tt posix}'' or ``{\tt windows}'', this specifies which platform-specific attributes
will be available. If the client does not recognize the platform string, it can only use the
platform-independent attributes.

Server should reply with a protocol version that is either the highest version supported, or equal to client
protocol version, whichever is lower. That means that if the server supports a version higher than the client,
it should downgrade to the client version. Server can only report higher version than the client if it is not
backwards-compatible with client version. In that case, client should probably abort the connection attempt.

If the client version is higher than the server version, client should either use the protocol version
supplied by server, or abort the connection attempt.

Format of extension fields is described in section \ref{ssec:extensions} Extension mechanism.

This concludes the session initialization. The client can now select an authentication mechanism and proceed
to the next step. If the server advertises the {\tt ANONYMOUS} mechanism, the client should select it, unless
the user indicates otherwise.

%

\subsection{SASL authentication}

This section of the work provides all relevant information in conformance with RFC~4422~\cite{rfc4422}
section~4 (Protocol Requirements). GSS-API service name is ``{\tt newtp}''.\footnote{The name is not
registered with IANA, so we do not technically conform to RFC~2743~\cite{rfc2743} requirements, and
transitively to RFC~4422 requirements either. For the purposes of this work, we consider this informal
conformance sufficient, seeing as hardly anyone will be using NewTP with GSS-API authentication in the
foreseeable future. At the time of this writing, the name ``{\tt newtp}'' is not allocated in the IANA service
registry.} NewTP does not allow multiple authentication, so any authentication exchange can be aborted by
disconnecting. This version of the protocol does not support separate authentication and authorization
identities, so authorization identity string should always be empty.

Mechanism negotiation is covered by the previous subsection. The core protocol does not allow the client to
rediscover available authentication mechanism after the authentication step is completed. We consider this
acceptable, because the session is already secured by TLS. For the same reason, the protocol is not using SASL
security layers even if they are available.

Scheme of the authentication exchange is described in RFC~4422. The client initiates the exchange, after which
the server can reply with a challenge and client reacts to that by sending a response. This can be repeated
zero or more times. At the end of the exchange, in reply to last client response, server sends an outcome
packet.  If the outcome is success, client is authenticated and can start sending commands. If the outcome is
failure, server will disconnect the client.

Client initiates the authentication exchange by sending one of the following packets:
\begin{enumerate}

\begin{samepage}
\item Initiation with mechanism name, {\it without} initial response
\begin{description}[parsep=1pt]
	\ttitem{string auth\_init} \hfill \\
		Fixed ASCII string ``{\tt A0}''
	\ttitem{uint16 length} \hfill \\
		Length of payload (in this case, only the mechanism name)
	\ttitem{string mechanism} \hfill \\
		Name of the selected mechanism
\end{description}
\end{samepage}

\begin{samepage}
\item Initiation with mechanism name, {\it with} initial response
\begin{description}[parsep=1pt]
	\ttitem{string auth\_init} \hfill \\
		Fixed ASCII string ``{\tt A1}''
	\ttitem{uint16 length} \hfill \\
		Length of payload
	\ttitem{uint16 mechanism\_len} \hfill \\
		Length of mechanism name
	\ttitem{string mechanism} \hfill \\
		Name of the selected mechanism
	\ttitem{uint16 response\_len} \hfill \\
		Length of initial response
	\ttitem{data response} \hfill \\
		Initial response
\end{description}
\end{samepage}

\end{enumerate}

\begin{samepage}
Server challenge packet format is as follows:
\begin{description}[parsep=1pt]
	\ttitem{string auth\_challenge} \hfill \\
		Fixed ASCII string ``{\tt AC}''
	\ttitem{uint16 length} \hfill \\
		Length of challenge
	\ttitem{data challenge} \hfill \\
		Contents of challenge
\end{description}
\end{samepage}

\begin{samepage}
Client response packet format is as follows:
\begin{description}[parsep=1pt]
	\ttitem{string auth\_response} \hfill \\
		Fixed ASCII string ``{\tt AR}''
	\ttitem{uint16 length} \hfill \\
		Length of response
	\ttitem{data response} \hfill \\
		Contents of response
\end{description}
\end{samepage}

At the end of the exchange, server will return an outcome in one of two ways:
\begin{enumerate}

\begin{samepage}
\item Outcome of authentication exchange, {\it without} additional data
\begin{description}[parsep=1pt]
	\ttitem{string auth\_outcome} \hfill \\
		Fixed ASCII string ``{\tt AF}'' (for ``Auth Finished'')
	\ttitem{uint16 length} \hfill \\
		Length of payload (in this case, 1)
	\ttitem{byte result} \hfill \\
		Result code
\end{description}
\end{samepage}

\begin{samepage}
\item Outcome {\it with} additional data
\begin{description}[parsep=1pt]
	\ttitem{string auth\_outcome} \hfill \\
		Fixed ASCII string ``{\tt AD}'' (for ``Auth outcome with Data'')
	\ttitem{uint16 length} \hfill \\
		Length of payload
	\ttitem{byte result} \hfill \\
		Result code
	\ttitem{uint16 adata\_len} \hfill \\
		Length of additional data
	\ttitem{data adata} \hfill \\
		Additional data
\end{description}
\end{samepage}

\end{enumerate}

TODO define codes for success and failure

%

\subsection{Request and response packets}

When the client is successfully authenticated, it can start sending {\it request} packets. Server will issue
exactly one {\it response} packet for each request packet received, in the order of reception. Client can send
any number of request packets without waiting for server reply. However, the server will process all requests
from the batch even if some of them fail, so where required, the client has to wait for confirmation of
success.

\begin{samepage}
Request packet header looks like this:
\begin{description}[parsep=1pt]
	\ttitem{uint16 request\_id} \hfill \\
		Arbitrary request ID
	\ttitem{byte extension} \hfill \\
		Extension code, {\tt 0x00} for core command
	\ttitem{byte command} \hfill \\
		Command code
	\ttitem{uint16 handle} \hfill \\
		File handle
	\ttitem{uint16 length} \hfill \\
		Length of payload
\end{description}
\end{samepage}

\begin{samepage}
Reply packet header is as follows:
\begin{description}[parsep=1pt]
	\ttitem{uint16 request\_id} \hfill \\
		Request ID from corresponding request
	\ttitem{byte extension} \hfill \\
		Extension code, {\tt 0x00} for core result code
	\ttitem{byte result} \hfill \\
		Result code
	\ttitem{uint16 length} \hfill \\
		Length of payload
\end{description}
\end{samepage}

Payload of request packet contains arguments for the command, data to be written etc. Payload of response
packet contains attribute query results, data read, details of error etc. 
%%

\begin{table}[h]
\begin{center}

\def\tline#1#2{ {\ttfamily #1} & {\ttfamily #2} }
\begin{tabular}{|cll|}
	\hline
	Code & Symbolic name & Description \\
	\hline
	\tline{0x00}{R\_OK} & Success \\
	\tline{0x01}{R\_CONTINUED} & Directory listing continued \\
	\tline{0x02}{R\_FINISHED} & Directory listing ends \\
	\hline

	\tline{0x80}{E\_BADPACKET} & Malformed request packet \\
	\tline{0x81}{E\_BADEXTENSION} & Unsupported extension \\
	\tline{0x82}{E\_BADCOMMAND} & Unrecognized command \\
	\tline{0x83}{E\_BADHANDLE} & File handle out of range \\
	\tline{0x84}{E\_BADPATH} & Path string is not acceptable \\
	\tline{0x85}{E\_DENIED} & Access denied \\
	\tline{0x86}{E\_BUSY} & Cannot access, try again later \\
	\tline{0x87}{E\_IO} & I/O error on server \\
	\tline{0x88}{E\_NOTFOUND} & Resource does not exist \\
		~ & ~ & Path component is not a directory \\
	\tline{0x89}{E\_NOTDIR} & Directory operation attempted on non-directory \\
	\tline{0x8A}{E\_NOTFILE} & File operation attempted on directory \\
	
	\hline

	\tline{0x90}{E\_BADATTR} & Unsupported attribute code \\
	\tline{0x91}{E\_CANNOTSET} & Specified attribute is not writable \\
	\tline{0x92}{E\_BADVALUE} & Specified attribute value is not acceptable \\

	\hline

	\tline{0xA0}{E\_BADOFFSET} & Read or write offset is not acceptable \\
	\tline{0xA1}{E\_TOOBIG} & File size limit reached \\
	\tline{0xA2}{E\_DEVFULL} & No space left on filesystem \\

	\hline

	\tline{0xB0}{E\_NOTEMPTY} & Attempting to delete a non-empty directory \\
	\tline{0xB1}{E\_BADMOVE} & Directory move would result in path loop \\
		~ & ~ & Move would overwrite a directory \\
		~ & ~ & Move would overwrite a file by a directory \\
		~ & ~ & New path component is not a directory \\
	\tline{0xB2}{E\_CROSSDEV} & Move crosses filesystem boundary \\
	\tline{0xB3}{E\_EXISTS} & Directory already exists \\
	\tline{0xB4}{E\_READDIR} & Directory is not rewound for reading \\

	\hline

	\tline{0xFE}{E\_FAIL} & Generic command failure \\
	\tline{0xFF}{E\_SERVFAIL} & Internal server error \\

	\hline
\end{tabular}

\end{center}
\caption{Result codes}
\label{table:results}
\end{table}

%%

\section{List of commands}

This section describes each command from the core set, its arguments, reply format and possible result codes.
Table \ref{table:results} describes all core result codes. Codes below {\tt 0x80} indicate success, codes
{\tt 0x80} and above indicate error.

Result code {\tt R\_OK} represents generic success, which is appropriate in most cases. Unless other success
codes can be returned as well, it is not mentioned in the description.

Result codes in the range {\tt 0x80}--{\tt 0x8f} are generic and can be returned by any command. These are not
mentioned in command descriptions, unless there are special concerns.  Result codes {\tt E\_FAIL} and {\tt
E\_SERVFAIL} indicate exceptional server states that might not be recoverable. The server might close the
connection after sending these codes. Continuing communication after receiving {\tt E\_SERVFAIL} is unsafe.

\subsection{ASSIGN}

Code: 0x00

Arguments:
string path

The only argument is the path string, its length is indicated by the {\tt length} field in header.

Assigns a new path to a file handle. Performs checks to verify that the path string is valid according to
section \ref{ssec:paths}, and that it conforms to OS or filesystem limitations. Does not check whether the
path or any of its components actually exist in the filesystem. Specifically this means that if the path
appears to confirm to filesystem rules, but turns out to be invalid when attempting to access it, calls other
than {\tt ASSIGN} can return {\tt E\_BADPATH} at a later point.

Result data: none

Specific errors: none

\subsection{STAT}

Code: 0x01

Arguments:
data attributes

The only argument is the set of queried attributes, its length is indicated by the {\tt length} field in
header.

Queries information about specified filesystem object. The returned information is a list of fields in the
order specified by the {\tt attributes} argument. Each attribute may appear only once.

Result data: depends on arguments

Specific errors:
	E\_BADATTR if an attribute code from the list is unknown or not supported on the platform
		{\it or} if an attribute is listed more than once

\subsection{SETATTR}

Code: 0x02

Arguments:
byte attribute
<any> value

Attempts to set an attribute {\tt attribute} to a new value {\tt value}.

Result data: none

Specific errors:
	E\_BADATTR if the attribute code is unknown or not supported on the platform
	E\_CANNOTSET if the attribute is not writable
	E\_BADVALUE if the attribute is writable, but the specified value cannot be set

\subsection{STATVFS}

Code: 0x03

Arguments: none

Queries filesystem information for the given path.

Result data:
uint32 device\_id // corresponds to the device\_id attribute
uint64 capacity // total filesystem size
uint64 free\_space // free space available
byte writable // 0x00 - read-only; 0x01 - writable

Specific errors: none

\subsection{READ}

Code: 0x10

Arguments:
uint64 offset
uint16 read\_len

Reads {\tt read\_len} bytes from file, starting at {\tt offset}. Returns exactly {\tt read\_len} bytes of
data, unless it encounters end of file or unless an error occurs. In case of error, returns data successfully
read before the error occured. If {\tt offset} points beyond end of file, returns success and zero-length
data.

Result data:
data data\_read

Specific errors:
	E\_BADOFFSET if the offset is not acceptable

\subsection{WRITE}
\label{ssec:WRITE}

Code: 0x11

Arguments:
uint64 offset
data write\_data

Length of {\tt write\_data}, further refered to as {\tt write\_len}, is calculated as $({\tt length} - 8)$.

Writes {\tt write\_len} bytes of data to a file, starting at {\tt offset}. Returns number of bytes written. On
success, this will be exactly {\tt write\_len}. On error, it might be a smaller number.

If the file does not exist, it is created. If {\tt write\_len} is zero, the server attempts to open the file
for writing but does not write any data. This can be used to create an empty file.

If the offset points beyond end of file, the command will attempt to transparently extend the file. This will
succeed if the filesystem supports sparse files. If not, the implementation can either extend the file by
appending null bytes until it reaches the offset, or return {\tt E\_BADOFFSET}. The implementation might
impose an arbitraty limit on how far the offset can be from the end of the file before {\tt E\_BADOFFSET} is
returned. If a size limit is reached or all disk space consumed while extending the file, the implementation
should return the appropriate error code and attempt to return the file to its previous state.

Result data:
uint16 bytes\_written

Specific errors:
	E\_BADOFFSET if the offset is not acceptable
	E\_TOOBIG the file size has reached a filesystem or operating system limit
	E\_DEVFULL no space left on device

\subsection{TRUNCATE}

Code: 0x12

Arguments:
uint64 size

Sets file size to specified value. If the file was larger than {\tt size}, its contents are truncated. If the
file was smaller than {\tt size}, the discussion from~\ref{ssec:WRITE} applies. Essentialy, when enlarging
a small file, results of {\tt TRUNCATE} and {\tt WRITE} with zero {\tt write\_len} are the same.

Does not implicitly create the file, may return {\tt E\_NOTFOUND} if the file does not exist.

Result data: none

Specific errors:
	E\_BADOFFSET if the offset is not acceptable
	E\_TOOBIG the file size has reached a filesystem or operating system limit
	E\_DEVFULL no space left on device

\subsection{DELETE}

Code: 0x20

Arguments: none

Deletes a file or an empty directory.

Result data: none

Specific errors:
	E\_NOTEMPTY if attempting to delete a directory that is not empty

\subsection{RENAME}

Code: 0x21

Arguments:
string newpath

Renames or moves a filesystem object so that its new path is {\tt newpath}. The new path must be in the same
filesystem tree. If moving a directory, the new path must not be inside the directory.

If the new path exists and is a file, and the file handle points to a file, the file at {\tt newpath} is
overwritten.

If the operation succeeds, the file handle is updated with the new path.

Result data: none

Specific errors:
	E\_BADPATH if the file handle path, {\it or} the new path, is not acceptable
	E\_BADMOVE if the move tries to make a directory loop (i.e., make a directory a subdirectory of itself)
		{\it or} if the new path exists and is a directory
		{\it or} if the new path exists and is a file, but file handle refers to a directory
		{\it or} if a component in the new path is not a directory
	E\_CROSSDEV if the move crosses filesystem boundaries

\subsection{MAKEDIR}

Code: 0x22

Arguments: none

Creates a directory. Fails if the directory already exists.

Result data: none

Specific errors:
	E\_EXISTS if the directory already exists

\subsection{REWINDDIR}

Code: 0x30

Arguments: none

Prepares directory for reading.

At session initialization, server informs the client of how many directories can be in the state ``prepared
for reading'' at any given time. This will usually be less than 10, some implementations may only allow one.
When {\tt REWINDDIR} is called on more directories than that, the first one loses the ``prepared for reading''
status in favor of the last one, etc. It is recommended that the client always completes directory listing of
one directory before moving on to another.

Result data: none

Specific errors: none

\subsection{READDIR}

Code: 0x31

Arguments:
data attributes

Reads as many directory entries as possible and returns them as names and the specified set of attributes.
Each attribute may be specified only once. Does not return {\tt R\_OK}: returns {\tt R\_CONTINUED} if there
are more items to be read, or {\tt R\_FINISHED} if no items remain. Every success packet, including the final
{\tt R\_FINISHED}, contains at least one directory entry.

If the command is interrupted by an error, result data will still contain the entries that were successfully
read. It is undefined whether ``prepared for reading'' state is lost on error.

To obtain full directory listing, client must first call {\tt REWINDDIR} and then repeat calling {\tt
READDIR} until it encounters {\tt R\_FINISHED} result code. At that point, ``prepared for reading'' state is
lost and subsequent reads will return {\tt E\_READDIR}.

Result data:
uint16 entries
(repeated (entries) times:
	uint16 name\_len
	string name
	<any> fields per the attributes argument
)

Specific errors:
	E\_BADATTR if an attribute code from the list is unknown or not supported on the platform
		{\it or} if an attribute is listed more than once
	E\_READDIR if the directory is not prepared for reading

%%

\section{Example session}

really??

%%

\section{Extensions}

this section describes the concept of the extension mechanism and lists some extensions

\subsection{Asynchronous operations}

Commands to fire off an operation (equivalent of some commands, plus on-server copy, recursive delete,
cross-filesystem move etc.) on a handle, command to monitor progress (depends on the command, by default
"none/in progress/finished"), command to abort.

\subsection{Extended attributes}

Commands to read and set extended attributes.

\subsection{Links}

Separate extensions for hardlinks and softlinks? Each with one command: link this path to this new name.

\subsection{Replay}

Remember results of certain operations in the main process and replay them to whoever asks.
