% vim: tw=110:fo=an1lt:nosmartindent

\chapter{Design of the new protocol}

We have developed a new file transfer protocol called NewTP (as a play on FTP, the original file transfer
protocol). This chapter describes the design decisions that went into the development, how the protocol
operates and what features it provides. We also describe how the extension mechanism works and define several
extensions.

%%

\section{Overview}

NewTP is a binary application protocol running on an encrypted channel with ordered and reliable delivery. It
is designed with TCP + TLS in mind; for this version, use of TLS 1.2 or later is mandatory. Communication is
split into packets with a fixed-length header and at most 64 kB of data. Client initiates all traffic. For
every client request packet, server must send exactly one reply packet, and it must send the replies in the
order in which it received the requests.

After an initial handshake, client must authenticate itself using the SASL protocol~\cite{rfc4422}. Where
appropriate, anonymous authentication mechanism will be available. A conforming implementation must support at
least anonymous and password-based authentication.\footnote{That is, {\tt ANONYMOUS} and {\tt PLAIN} SASL
mechanisms.}

Once the session is established, client sends requests and receives replies in a common format. A request
header contains code of the command, file handle to which it applies, arbitrarily chosen request ID, and
length of data payload. The reply repeats the request ID, adds a result code and payload length.  Although
this version of the protocol does not allow it, future revisions might let the server reorder replies, in
which case the request ID will be used to match replies to corresponding requests.

Core NewTP command set consists of ranged read, ranged write with implicit file creation, truncate operation,
directory listing that includes selected metadata attributes, creating directories, delete and rename/move
operations, metadata querying and manipulation. Additional commands can be added through an extension
mechanism without changing the protocol.

\section{Design decisions}

The protocol is intended as a lightweight file transfer protocol with some filesystem-like features. We wanted
to limit its feature set for ease of implementation, provide reasonable performance on high-latency networks,
ensure cross-platform interoperability, and make the protocol secure by default.

\subsection{Supported scenarios}

NewTP is designed with three main usecases in mind.

\subsubsection{Local fileserver}

In this scenario, the NewTP server is placed on a private local network or a VPN and provides a shared
document and multimedia store for its users. The network is considered a trusted environment, and the server
assumes that clients allowed to connect to the network are automatically entitled to access the document
store.  Encryption is not essential and authentication is completely unnecessary. Filesystem-like features are
desirable for operating system integration, but advanced locking and conflict resolution features are not
required, because conflicts will usually be resolved on the human level. This is the case for file servers or
media centers on home networks. Users in this scenario don't necessarily have technical background, so neither
the protocol nor its implementations should place any barriers to ease of use.

\subsubsection{Temporary share on a public network}

Users connected to the same network want to quickly exchange files. One of them sets up a NewTP server on
their computer, the others connect to it and download the published files or upload their own data. After all
transfers are done, the server is shut down. The network is assumed to be untrusted -- it might be an open WiFi
in a restaurant or a shared building-wide LAN -- so we require encryption, authentication and MitM protection.
However, the users are assumed to have a communication side-channel, such as close physical proximity, so
there is no need for any sort of PKI. The emphasis is on the ability to set up a server quickly, without
complicated supporting infrastructure. Ideally, both server and client software are implemented as portable
executables that the users can download and run with minimum of configuration. Filesystem-like features are
not required, because the users only need upload, download and directory manipulation capabilities.

\subsubsection{Shared Internet fileserver}

A web hosting or cloud storage provider sets up a NewTP server connected to the Internet. Clients of the
provider are issued credentials and use the NewTP protocol to access their files. Obviously, encryption and
MitM protection is required. However, in this scenario, it is more difficult to verify authenticity of the
server. Its certificate must either be verifiable through a PKI, or a through a side-channel such as physical
mail.  Implementations should also check for certificate changes.

A single server will be serving multiple users, so the protocol must provide user accounts and the
implementation will publish different parts of the filesystem based on which user account is authenticated.
Users will be using both dedicated NewTP clients and operating system integration, so filesystem-like
features, although not strictly required, are strongly desirable.


\subsection{Simplicity}

Simplicity means different things to different people and in different contexts. In case of NewTP, we want to
ensure that the protocol is simple to implement and use properly. The core feature set is small and
variability of commands is limited. Individual commands mostly correspond to how the operating system works
with filesystems, so each command can usually be implemented with one or two system calls on the server. On
the client, it is easy to replicate common file operations with calls over the network. In difficult cases, we
opt for less complex solutions that work well for our supported scenarios, even if they do not perfectly cover
corner cases.

Simplicity is also the reason for choosing TCP as the transport layer. This way, the protocol does not need to
concern itself with lost or out-of-order packets.

\subsection{Secure by default}

Protocols designed before the rise of Internet usually provide encryption as an optional feature. This leads
to widespread practice of using unencrypted connections on insecure public networks. We want to avoid this
practice with NewTP. Therefore, the protocol mandates use of TLS 1.2 or later for every connection.
Furthermore, we recommend that implementations use the highest available version of TLS at a given time, and
disable weak ciphersuites.

Especially in the ``local fileserver'' and ``temporary share'' scenarios, it is unrealistic to expect that
users would obtain a certificate from a trusted certificate authority, much less roll their own.
Implementations must allow self-signed certificates by default, and for ease of use, server applications
should generate their own certificates automatically. To ensure that attacker does not impersonate
a legitimate server with a brand new self-signed certificate, clients should remember certificates on first
connection and warn the user if the certificate has changed.\footnote{This practice is known as {\it
certificate pinning}.}

We attempted to design NewTP so that implementing it does not easily lead to buffer overflows.  Packet size is
limited to 64 kB, so every packet can fit into a fixed-size buffer. The protocol is binary and most packet
structures have a predefined size. Strings are not null-terminated, so the implementation is forced to use the
corresponding length field. Same is true for lists of structs. Where possible, length information is not
duplicated so implementations cannot be fooled by a mismatch. Simplicity of the protocol also means that the
client can't easily tie up disproportionately huge amounts of server processing power with a small number
of~requests.

\subsection{Low latency}

Given that the protocol is using TLS on top of TCP, establishing a connection takes a nontrivial amount of
time. This is even more true on high-latency networks like GPRS/EDGE. We want to make operation on such
networks as painless as possible. That means good support for interleaving of operations on a single
connection, and reducing size of protocol messages.

The choice of a binary protocol results in smaller messages. In addition, we recommend enabling TLS
compression. The short maximum packet length means that in the ideal case, after a new operation is inserted
into the outgoing stream, the client downloads at most 64 kB of data before receiving a response for the newly
inserted operation. In practice, clients on high-latency networks will batch requests, so that when the new
operation is inserted, it has to wait before the whole preceding batch is processed. However, there is room
for implementations to perform flow control and send batched messages only as fast as they can receive
responses, in which case it is possible to insert commands midway through.

This sort of interleaving rules out long operations, which is helpful even on fast networks. It means that it
is easy to implement a responsive filesystem emulation on top of NewTP.

Transfer overhead works out to 24 bytes per 64 kB when using maximum possible packet size. To put this in
perspective, when downloading 2 GB of data at top speed, protocol overhead will consume additional 786 kB.
This is perfectly acceptable.

\subsection{Authentication is optional}

In the ``local fileserver'' scenario, we don't want the clients to authenticate. In the ``temporary share'',
the authentication is supposed to be short and simple, probably based on a passphrase. In the ``Internet
fileserver'' scenario, strongest possible authentication is required, possibly including client certificates
or two-factor authentication.

We decided to implement authentication through the SASL protocol. This allows us to use a wide range of
authentication mechanisms, ranging from anonymous access, to plaintext usernames and password, to digest-based
authentication. Also, with SASL, new authentication mechanisms can be supported by implementations without
changing the NewTP protocol. Reusing an existing technology (SASL is implemented by a number of widely
available libraries) also reduces work for implementers.

The fact that SASL supports anonymous authentication allows us to make the SASL process mandatory, while still
technically keeping authentication optional. This again simplifies the protocol.

\subsection{Concurrency is out of scope}

NewTP is intended to service usecases with minimal interactions between users and negligible amounts of
conflicts. Because of that, we decided not to put any locking mechanisms into the protocol. Locking is
a decidedly complex problem in itself, and it is not a problem that NewTP is trying to solve.

We take concurrency issues into consideration and make reasonable attempts to prevent or solve them. We expect
that locking mechanisms could be implemented as protocol extensions, either by third parties or in a future
revision of the protocol. In general, however, we consider reliable concurrency to be out of scope, and
recommend using a different protocol for scenarios that require it.

\subsection{Caching policy}

In this version of the protocol, clients are fully responsible for managing their caches.  Depending on the
application, a client should periodically check freshness of relevant data.  For filesystem emulation, clients
should check cache freshness every time a file is opened, and perform server write when the file is closed.
In addition, it is advisable to refresh directory cache at reasonable intervals, e.g. once a minute.  (XXX
really?)

We considered adding a mechanism through which the server could request cache invalidation. However, since all
traffic is initiated by the client, server has no means to send unsolicited updates. Adding this would
complicate client implementations and we did not want that. Alternately, clients could register watched items
and then use a single command to poll their status periodically. We did not make this a part of the core
protocol, but a future revision might introduce an extension with this functionality.

\subsection{Non-idempotent operations}

Since native locking is not part of the protocol, we make an attempt to minimize problems with directory-based
locking and mitigate potential issues with non-idempotent operations. To this end, we have designed
a ``Replay'' extension. After establishing a session and authenticating, the client can ask for a unique
session token. If the connection is lost, the client can reconnect, and after a successful authentication, ask
for a replay of the session identified by that token. The server will reply with results for the last few
non-idempotent operations recorded under the provided token. If the session is still alive on the server, it
will be terminated to prevent late delivery of further commands. This way the client can resume after the last
command that was successfully received by the server.

Security of this extension is ensured by using tokens that are long enough to prevent guessing, and only
providing the replay to the same user account. Implementations might also check that the new connection is
coming from the same host as the old one.

%%

\section{Building blocks}

This section describes mechanics of NewTP in greater technical detail. It should be useful as a reference for
implementers.

\subsection{Packet format notation}

Packets are described in a C-style format, data type preceding field name. Various packets use data types
defined as follows:

\def\ttitem#1{ \item[\ttfamily #1] \hfill \\ }
\begin{description}
	\ttitem{byte} An 8-bit value (octet). Bytes represent command codes, result codes and other fields
		where the value is one of a fixed set of possibilities. The values are written out in
		hexadecimal notation, e.g. {\tt 0x07}.
	\ttitem{uint16} Unsigned 16-bit integer
	\ttitem{uint64} Unsigned 64-bit integer
	\ttitem{string} Byte sequence of arbitrary length, representing a valid Unicode codepoint string
		encoded in UTF-8. The field is not null-terminated. Length is not part of the {\tt string}
		field, a separate {\tt uint16} length information must precede it.
	\ttitem{data} Byte sequence of arbitrary length, representing arbitrary data. Same as {\tt string},
		length must be specified separately.
\end{description}

\subsection{Path string encoding}

All filenames and path strings, expressed as {\tt string} fields in packet descriptions, must be encoded as
UTF-8. Clients and servers must perform transcoding from system-native filename encoding to UTF-8 and back.

To support filenames that are undecodable in the system encoding, NewTP uses a roundtrip-safe encoding scheme
described in PEP~383~\cite{pep383}. In this scheme, an undecodable byte {\tt 0x80}--{\tt 0xFF} is converted to
a lone surrogate codepoint {\tt U+DC80}--{\tt U+DCFF}, which is then encoded to a 3-byte sequence by the UTF-8
algorithm. Upon receiving the string, reverse conversion or implementation-defined handling of the string is
performed.

Surrogates are codepoints reserved for UTF-16 encoding of codepoints above the Basic Multilingual Plane. They
are only valid as pairs in UTF-16, and not valid in UTF-8 at all. Therefore, a valid encoding cannot produce
a string which contains a lone surrogate codepoint, so there are no conflicts with this encoding scheme. Note
that this means that a string using this encoding scheme is not valid UTF-8. Implementations must be prepared
to handle potential UTF-8 decoding errors.

This encoding scheme does not cover all cases. Notably, in some encodings, bytes {\tt 0x00} through {\tt 0x7F}
can be parts of undecodable sequences. These are not supported for security reasons: it might be possible to
``smuggle in'' ASCII sequences such as `{\tt /..}', thus opening a new attack surface that must be checked by
implementations. See PEP~383~\cite{pep383} for full discussion. In NewTP, such bytes are instead to be
replaced by the Unicode replacement character {\tt U+FFFD}.

Also note that certain encodings, such as Big5, cannot be roundtrip-safely decoded to Unicode, because
multiple byte sequences map to the same Unicode codepoint. These are not supported by the core protocol.

\subsection{Path strings and file handles}

Paths and files in NewTP are referred to through file handles. The {\tt ASSIGN} command assigns a path string
to a file handle, and subsequent commands use the file handle as an argument, instead of the path string. The
purpose of this is to limit repeating of the potentially long path string.

File handles do not necessarily refer to valid filesystem objects -- for example, to create a new directory,
the client assigns the new path to a file handle and then issues a {\tt MAKEDIR} command on that handle.
A file handle does not become invalid when the object it is pointing to is removed, and it does not follow
externally moved files.\footnote{Although as a side-effect, the {\tt RENAME} command updates the file handle
with the new path.}

We wanted to avoid the necessity to open a file before writing, and the complexity associated with managing
``persistent'' open-file handles on the server. This means that several common POSIX usage patterns are not
directly supported: writing to a deleted or moved file recreates the original name instead of continuing to
write to the new location (or to the ``ghost'' version). These usage patterns can be emulated on the client if
necessary; making this work correctly in concurrent scenarios is out of scope for NewTP.

\subsection{Attributes}

how we work with attributes: there are predefined lists, directory listing will return the default list for
each entry and after that, a platform-dependent list. implementations may or may not use the second list.

\subsection{Request and response packets}

Request header contains command id, handle id and operation id, plus length of payload. Payload may contain
further arguments for the command. Response header contains payload length, operation id and return code.
Smaller than 0x80 is OK, 0x80 and above is error.  The codes have predefined meanings.

\subsection{Communication scheme}

Client starts by sending hello, then it authenticates, then it fires commands and gets responses.  In the
first version, responses come in the same order as commands. There is no QUIT command, client simply
disconnects and server discards all (most?) state. When establishing the session, different packet format is
used, this way a future version only needs to keep the hello message and redefine other packets.

\subsection{Example session}

TODO -- only a table?

%%

\section{List of commands}

Complete list of core commands, with descriptions, arguments, etc.

\subsection{ASSIGN}

\subsection{STAT}

\subsection{SETATTR}

\subsection{STATVFS}

\subsection{READ}

\subsection{WRITE}

\subsection{TRUNCATE}

\subsection{DELETE}

\subsection{RENAME}

\subsection{MAKEDIR}

\subsection{REWINDDIR}

\subsection{READDIR}


%%

\section{Result codes}

TODO -- only a table?

%%

\section{Extensions}

this section describes the concept of the extension mechanism and lists some extensions

\subsection{Asynchronous operations}

Commands to fire off an operation (equivalent of some commands, plus on-server copy, recursive delete,
cross-filesystem move etc.) on a handle, command to monitor progress (depends on the command, by default
"none/in progress/finished"), command to abort.

\subsection{Extended attributes}

Commands to read and set extended attributes.

\subsection{Links}

Separate extensions for hardlinks and softlinks? Each with one command: link this path to this new name.

\subsection{Replay}

Remember results of certain operations in the main process and replay them to whoever asks.
