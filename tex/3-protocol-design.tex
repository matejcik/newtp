% vim: tw=110:fo=an1lt:nosmartindent

\chapter{Design of the new protocol}

We have developed a new file transfer protocol called NewTP (as a play on FTP, the original file transfer
protocol). This chapter describes the design decisions that went into the development, how the protocol
operates and what features it provides. We also describe how the extension mechanism works and define several
extensions.

%%

\section{Design decisions}

The protocol is intended as a lightweight file transfer protocol with some filesystem-like features. We wanted
to limit its feature set for ease of implementation, provide reasonable performance on high-latency networks,
ensure cross-platform interoperability in today's computing environments, and make the protocol secure by
default.

\subsection{Supported scenarios}

NewTP is designed with three main usecases in mind.

\subsubsection{Local fileserver}

In this scenario, the NewTP server is placed on a private local network or a VPN and provides a shared
document and multimedia store for its users. The network is considered a trusted environment, and the server
assumes that clients allowed to connect to the network are automatically entitled to access the document
store.  Encryption is not essential and authentication is completely unnecessary. Filesystem-like features are
desirable for operating system integration, but advanced locking and conflict resolution features are not
required, because conflicts will usually be resolved on the human level. This is the case for file servers or
media centers on home networks. Users in this scenario don't necessarily have technical background, so neither
the protocol nor its implementations should place any barriers to ease of use.

\subsubsection{Temporary share on a public network}

Users connected to the same network want to quickly exchange files. One of them sets up a NewTP server on
their computer, the others connect to it and download the published files or upload their own data. After all
transfers are done, the server is shut down. The network is assumed to be untrusted -- it might be an open WiFi
in a restaurant or a shared building-wide LAN -- so we require encryption, authentication and MitM protection.
However, the users are assumed to have a communication side-channel, such as close physical proximity, so
there is no need for any sort of PKI. The emphasis is on the ability to set up a server quickly, without
complicated supporting infrastructure. Ideally, both server and client software are implemented as portable
executables that the users can download and run with minimum of configuration. Filesystem-like features are
not required, because the users only need upload, download and directory manipulation capabilities.

\subsubsection{Shared Internet fileserver}

A web hosting or cloud storage provider sets up a NewTP server connected to the Internet. Clients of the
provider are issued credentials and use the NewTP protocol to access their files. Obviously, encryption and
MitM protection is required. However, in this scenario, it is more difficult to verify authenticity of the
server. Its certificate must either be verifiable through a PKI, or a through a side-channel such as physical
mail.  Implementations should also check for certificate changes.

A single server will be serving multiple users, so the protocol must provide user accounts and the
implementation will publish different parts of the filesystem based on which user account is authenticated.
Users will be using both dedicated NewTP clients and operating system integration, so filesystem-like
features, although not strictly required, are strongly desirable.


\subsection{Simplicity}

Simplicity means different things to different people and in different contexts. In case of NewTP, we want to
ensure that the protocol is simple to implement and use properly. The core feature set is small and
variability of commands is limited. Individual commands mostly correspond to how the operating system works
with filesystems, so each command can usually be implemented with one or two system calls on the server -- and
on the client, it is easy to replicate common file operations with calls over the network. In difficult cases,
we opt for less complex solutions that work well for our supported scenarios, even if they do not perfectly
cover corner cases.

Simplicity is also the reason for choosing TCP as the transport layer. This way, the protocol does not need to
concern itself with lost or out-of-order packets.

\subsection{Secure by default}

Protocols designed before the rise of Internet usually provide encryption as an optional feature. This leads
to widespread practice of using unencrypted connections on insecure public networks. We want to avoid this
practice with NewTP. Therefore, the protocol mandates use of TLS 1.2 or later for every connection.
Furthermore, we recommend that implementations use the highest available version of TLS at a given time, and
disable weak ciphersuites.

Especially in the ``local fileserver'' and ``temporary share'' scenarios, it is unrealistic to expect that the
users would obtain a certificate from a trusted certificate authority, much less roll their own.
Implementations must allow self-signed certificates by default, and for ease of use, server applications
should generate their own certificates automatically. To ensure that attacker does not impersonate
a legitimate server with a brand new self-signed certificate, clients should remember certificates on first
connection and warn the user if the certificate has changed.\footnote{This practice is known as {\it
certificate pinning}.}

We attempted to design NewTP so that implementing it does not easily lead to buffer overflows.  Packet size is
limited to 64 kB, so every packet can fit into a fixed-size buffer. The protocol is binary and most packet
structures have a predefined size. Strings are not null-terminated, so the implementation is forced to use the
corresponding length field. Same is true for lists of structs. Simplicity of the protocol also means that the
client can't easily tie up excessive amounts of server processing power with short requests.

\subsection{Low latency}

Given that the protocol is using TLS on top of TCP, establishing a connection takes a nontrivial amount of
time. This is even more true on high-latency networks like GPRS/EDGE. We want to make operation on such
networks as painless as possible. That means good support for interleaving of operations on a single
connection, and reducing size of protocol messages.

The choice of a binary protocol results in smaller messages. The short maximum packet length means that in the
ideal case, after a new operation is inserted into the outgoing stream, the client downloads at most 64 kB of
data before receiving a response for the newly inserted operation. In practice, clients on high-latency
networks will batch requests, so that when the new operation is inserted, it has to wait before the whole
preceding batch is processed. However, there is room for implementations to perform a sort of flow control and
send batched messages only as fast as they can receive responses, in which case it is possible to interleave
the batch midway through.

This sort of interleaving rules out long operations, which is helpful even on fast networks. It means that it
is easy to implement a responsive filesystem emulation on top of NewTP.

The obvious drawback is that transfer overhead is relatively big, compared to protocols with packets in the
megabyte range. However, XXX bytes of overhead per 64 kB of payload works out to XXX \% more data, which is
acceptable.

\subsection{Authentication is optional}

In the ``local fileserver'' scenario, we don't want the clients to authenticate. In the ``temporary share'',
the authentication is supposed to be short and simple, probably based on a passphrase. In the ``Internet
fileserver'' scenario, strongest possible authentication is required, possibly including client certificates
or two-factor authentication. Therefore, we must support several authentication mechanisms within the same
protocol.

We decided to implement authentication through the SASL protocol~\cite{rfc4422}. This allows us to use a wide
range of authentication mechanisms, ranging from anonymous access, to plaintext usernames and password, to
digest-based authentication. Also, with SASL, new authentication mechanisms can be supported by
implementations without changing the NewTP protocol. Reusing an existing technology (SASL is implemented by
a number of widely available libraries) also reduces work for implementers.

\subsection{Caching policy}

TODO

\subsection{Path string encoding}

TODO

We use UTF-8 for everything everywhere. But we want to support undecodable filenames as well, so for them, we
reserve an Unicode private range, and each undecodable character is sent as 0x123456 + its byte value.

\subsection{Directory creation}

Since we won't support real locks, we will support create-directory locks. This requires certain amount of
smartness on our side, and it's still far from perfect.

%%

\section{Building blocks}

How the new protocol actually operates?

\subsection{Packet format notation}

Basically the same as in RFC 4251 -- byte, uint16 etc.

\subsection{File handles}

are everything. You first need to assign a path to a handle, then you can do whatever with it. Handles can
have state: position in file or in directory listing.

\subsection{Attributes}

how we work with attributes: there's a predefined list that covers unices and windows, you can select which
ones you want to get with directory listing, by default you get "whatever local stat() returns", server tells
you what it is at start, you can reconfigure

\subsection{Request and response packets}

Each "packet" contains 16bit length of rest of the packet, followed by mandatory header, followed by
(optional) arguments for current command. Request header contains command id, handle id and operation id.
Response header contains operation id and return code. Smaller than 0x80 is OK, 0x80 and above is error. The
codes have predefined meanings.

\subsection{Communication scheme}

Client starts by sending hello, then it can authenticate if it wants, then it fires commands and gets
responses. In the first version, responses come in the same order as commands. There is no QUIT command,
client simply disconnects and server discards all (most?) state.

\subsection{Example session}

TODO -- only a table?

%%

\section{List of commands}

Complete list of core commands, with descriptions, arguments, etc.

\subsection{PING}

\subsection{HELLO}

\subsection{ASSIGN}

\subsection{STAT}

\subsection{STATVFS}

\subsection{SEEK}

\subsection{READ}

\subsection{WRITE}

\subsection{APPEND}

\subsection{TRUNCATE}

\subsection{DELETE}

\subsection{RENAME}

\subsection{MAKEDIR}

\subsection{REWINDDIR}

\subsection{READDIR}

\subsection{SETATTR}

\subsection{which-attributes-to-show-in-readdir}

%%

\section{Result codes}

TODO -- only a table?

%%

\section{Extensions}

this section describes the concept of the extension mechanism and lists some extensions

\subsection{Authentication}

Authentication is optional, so it is implemented as an extension even though it is integral to the server. The
server will advertise presence of the extension and that's how client knows it can authenticate.

\subsection{Asynchronous operations}

Commands to fire off an operation (equivalent of some commands, plus on-server copy, recursive delete,
cross-filesystem move etc.) on a handle, command to monitor progress (depends on the command, by default
"none/in progress/finished"), command to abort.

\subsection{Extended attributes}

Commands to read and set extended attributes.

\subsection{Links}

Separate extensions for hardlinks and softlinks? Each with one command: link this path to this new name.
