% vim: tw=110:fo=an1lt:nosmartindent

\chapter{Design of the new protocol}

We have developed a new file transfer protocol called NewTP (as a play on FTP, the original file transfer
protocol). This chapter describes the design decisions that went into the development, how the protocol
operates and what features it provides. We also describe how the extension mechanism works and define several
extensions.

%%

\section{Overview}

NewTP is a binary application protocol running on an encrypted channel with ordered and reliable delivery. It
is designed with TCP + TLS in mind; for this version, use of TLS 1.2 or later is mandatory. Communication is
split into packets with a fixed-length header and at most 64 kB of data. Client initiates all traffic. For
every client request packet, server must send exactly one reply packet, and it must send the replies in the
order in which it received the requests.

After an initial handshake, client must authenticate itself using the SASL protocol~\cite{rfc4422}. Where
appropriate, anonymous authentication mechanism will be available. A conforming implementation must support at
least anonymous and password-based authentication.\footnote{That is, {\tt ANONYMOUS} and {\tt PLAIN} SASL
mechanisms.}

Once the session is established, client sends requests and receives replies in a common format. Every command
operates on an object refered to by a file handle. Before use, client must set up the file handle by assigning
a path string to it. Requests specify an arbitrary ID that is repeated in the reply; although this version of
the protocol does not allow it, future revisions might let the server reorder replies, in which case the
request ID will be used to match replies to corresponding requests.

Core NewTP command set consists of ranged read, ranged write with implicit file creation, truncate operation,
directory listing that includes selected metadata attributes, creating directories, delete and rename/move
operations, metadata querying and manipulation. Additional commands can be added through an extension
mechanism without changing the protocol.

%%

\section{Design decisions}

The protocol is intended as a lightweight file transfer protocol with some filesystem-like features. We wanted
to limit its feature set for ease of implementation, provide reasonable performance on high-latency networks,
ensure cross-platform interoperability, and make the protocol secure by default.

%

\subsection{Supported scenarios}

NewTP is designed with three main usecases in mind.

%

\subsubsection{Local fileserver}

In this scenario, the NewTP server is placed on a private local network or a VPN and provides a shared
document and multimedia store for its users. The network is considered a trusted environment, and the server
assumes that clients allowed to connect to the network are automatically entitled to access the document
store.  Encryption is not essential and authentication is completely unnecessary. Filesystem-like features are
desirable for operating system integration, but advanced locking and conflict resolution features are not
required, because conflicts will usually be resolved on the human level. This is the case for file servers or
media centers on home networks. Users in this scenario don't necessarily have technical background, so neither
the protocol nor its implementations should place any barriers to ease of use.

%

\subsubsection{Temporary share on a public network}

Users connected to the same network want to quickly exchange files. One of them sets up a NewTP server on
their computer, the others connect to it and download the published files or upload their own data. After all
transfers are done, the server is shut down. The network is assumed to be untrusted -- it might be an open WiFi
in a restaurant or a shared building-wide LAN -- so we require encryption, authentication and MitM protection.
However, the users are assumed to have a communication side-channel, such as close physical proximity, so
there is no need for any sort of PKI. The emphasis is on the ability to set up a server quickly, without
complicated supporting infrastructure. Ideally, both server and client software are implemented as portable
executables that the users can download and run with minimum of configuration. Filesystem-like features are
not required, because the users only need upload, download and directory manipulation capabilities.

%

\subsubsection{Shared Internet fileserver}

A web hosting or cloud storage provider sets up a NewTP server connected to the Internet. Clients of the
provider are issued credentials and use the NewTP protocol to access their files. Obviously, encryption and
MitM protection is required. However, in this scenario, it is more difficult to verify authenticity of the
server. Its certificate must either be verifiable through a PKI, or a through a side-channel such as physical
mail.  Implementations should also check for certificate changes.

A single server will be serving multiple users, so the protocol must provide user accounts and the
implementation will publish different parts of the filesystem based on which user account is authenticated.
Users will be using both dedicated NewTP clients and operating system integration, so filesystem-like
features, although not strictly required, are strongly desirable.

%

\subsection{Simplicity}

Simplicity means different things to different people and in different contexts. In case of NewTP, we want to
ensure that the protocol is simple to implement and use properly. The core feature set is small and
variability of commands is limited. Individual commands mostly correspond to how the operating system works
with filesystems, so each command can usually be implemented with one or two system calls on the server. On
the client, it is easy to replicate common file operations with calls over the network. In difficult cases, we
opt for less complex solutions that work well for our supported scenarios, even if they do not perfectly cover
corner cases.

Simplicity is also the reason for choosing TCP as the transport layer. This way, the protocol does not need to
concern itself with lost or out-of-order packets.

%

\subsection{Secure by default}

Protocols designed before the rise of Internet usually provide encryption as an optional feature. This leads
to widespread practice of using unencrypted connections on insecure public networks. We want to avoid this
practice with NewTP. Therefore, the protocol mandates use of TLS 1.2 or later for every connection.
Furthermore, we recommend that implementations use the highest available version of TLS at a given time, and
disable weak ciphersuites.

Especially in the ``local fileserver'' and ``temporary share'' scenarios, it is unrealistic to expect that
users would obtain a certificate from a trusted certificate authority, much less roll their own.
Implementations must allow self-signed certificates by default, and for ease of use, server applications
should generate their own certificates automatically. To ensure that attacker does not impersonate
a legitimate server with a brand new self-signed certificate, clients should remember certificates on first
connection and warn the user if the certificate has changed.\footnote{This practice is known as {\it
certificate pinning}.}

We attempted to design NewTP so that implementing it does not easily lead to buffer overflows.  Packet size is
limited to 64 kB, so every packet can fit into a fixed-size buffer. The protocol is binary and most packet
structures have a predefined size. Strings are not null-terminated, so the implementation is forced to use the
corresponding length field. Same is true for lists of structs. Where possible, length information is not
duplicated so implementations cannot be fooled by a mismatch. Simplicity of the protocol also means that the
client can't easily tie up disproportionately huge amounts of server processing power with a small number
of~requests.

%

\subsection{Low latency}

Given that the protocol is using TLS on top of TCP, establishing a connection takes a nontrivial amount of
time. This is even more true on high-latency networks like GPRS/EDGE. We want to make operation on such
networks as painless as possible. That means good support for interleaving of operations on a single
connection, and reducing size of protocol messages.

The choice of a binary protocol results in smaller messages. In addition, we recommend enabling TLS
compression. The short maximum packet length means that in the ideal case, after a new operation is inserted
into the outgoing stream, the client downloads at most 64 kB of data before receiving a response for the newly
inserted operation. In practice, clients on high-latency networks will batch requests, so that when the new
operation is inserted, it has to wait before the whole preceding batch is processed. However, there is room
for implementations to perform flow control and send batched messages only as fast as they can receive
responses, in which case it is possible to insert commands midway through.

This sort of interleaving rules out long operations, which is helpful even on fast networks. It means that it
is easy to implement a responsive filesystem emulation on top of NewTP.

Transfer overhead works out to 24 bytes per 64 kB when using maximum possible packet size. To put this in
perspective, when downloading 2 GB of data at top speed, protocol overhead will consume additional 786 kB.
This is perfectly acceptable.

%

\subsection{Authentication is optional}

In the ``local fileserver'' scenario, we don't want the clients to authenticate. In the ``temporary share'',
the authentication is supposed to be short and simple, probably based on a passphrase. In the ``Internet
fileserver'' scenario, strongest possible authentication is required, possibly including client certificates
or two-factor authentication.

We decided to implement authentication through the SASL protocol. This allows us to use a wide range of
authentication mechanisms, ranging from anonymous access, to plaintext usernames and password, to digest-based
authentication. Also, with SASL, new authentication mechanisms can be supported by implementations without
changing the NewTP protocol. Reusing an existing technology (SASL is implemented by a number of widely
available libraries) also reduces work for implementers.

The fact that SASL supports anonymous authentication allows us to make the SASL process mandatory, while still
technically keeping authentication optional. This again simplifies the protocol.

%

\subsection{Concurrency is out of scope}

NewTP is intended to service usecases with minimal interactions between users and negligible amounts of
conflicts. Because of that, we decided not to put any locking mechanisms into the protocol. Locking is
a decidedly complex problem in itself, and it is not a problem that NewTP is trying to solve.

We take concurrency issues into consideration and make reasonable attempts to prevent or solve them. We expect
that locking mechanisms could be implemented as protocol extensions, either by third parties or in a future
revision of the protocol. In general, however, we consider reliable concurrency to be out of scope, and
recommend using a different protocol for scenarios that require it.

%

\subsection{Caching policy}

In this version of the protocol, clients are fully responsible for managing their caches.  Depending on the
application, a client should periodically check freshness of relevant data.  For filesystem emulation, clients
should check cache freshness every time a file is opened, and perform server write when the file is closed.
In addition, it is advisable to refresh directory cache at reasonable intervals, e.g. once a minute.  (XXX
really?)

We considered adding a mechanism through which the server could request cache invalidation. However, since all
traffic is initiated by the client, server has no means to send unsolicited updates. Adding this would
complicate client implementations and we did not want that. Alternately, clients could register watched items
and then use a single command to poll their status periodically. We did not make this a part of the core
protocol, but a future revision might introduce an extension with this functionality.

%

\subsection{Non-idempotent operations}

Since native locking is not part of the protocol, we make an attempt to minimize problems with directory-based
locking and mitigate potential issues with non-idempotent operations. To this end, we have designed
a ``Replay'' extension. After establishing a session and authenticating, the client can ask for a unique
session token. If the connection is lost, the client can reconnect, and after a successful authentication, ask
for a replay of the session identified by that token. The server will reply with results for the last few
non-idempotent operations recorded under the provided token. If the session is still alive on the server, it
will be terminated to prevent late delivery of further commands. This way the client can resume after the last
command that was successfully received by the server.

Security of this extension is ensured by using tokens that are long enough to prevent guessing, and only
providing the replay to the same user account. Implementations might also check that the new connection is
coming from the same host as the old one.

%%

\section{Building blocks}

This section describes various technical details pertaining to design and implementation of NewTP.

%

\subsection{Packet format notation}

Packets are described in a C-style format, data type preceding field name. Various packets use data types
defined as follows:

\def\ttitem#1{ \item[\ttfamily #1] }
\begin{description}[leftmargin=1.7cm,style=sameline]
	\ttitem{byte} An 8-bit value (octet). Bytes represent command codes, result codes and other fields
		where the value is one of a fixed set of possibilities. The values are written out in
		hexadecimal notation, e.g. {\tt 0x07}.
	\ttitem{uint16} Unsigned 16-bit integer
	\ttitem{uint32} Unsigned 32-bit integer
	\ttitem{uint64} Unsigned 64-bit integer
	\ttitem{time\_t} Unsigned 64-bit integer, representing time in microseconds since the start of UNIX
		epoch (1 January 1970, 0:00:00 UTC)
	\ttitem{string} Byte sequence of arbitrary length, representing a Unicode string encoded in UTF-8.
		The field is not null-terminated. Length is not part of the {\tt string} field, a separate
		{\tt uint16} length information must precede it.
	\ttitem{data} Byte sequence of arbitrary length, representing arbitrary data. Same as {\tt string},
		length must be specified separately.
\end{description}

%

\subsection{Path string encoding}

All filenames and path strings, expressed as {\tt string} fields in packet descriptions, must be encoded as
UTF-8. Clients and servers must perform transcoding from system-native filename encoding to UTF-8 and back.

To support filenames that are undecodable in the system encoding, NewTP uses a roundtrip-safe encoding scheme
described in PEP~383~\cite{pep383}. In this scheme, an undecodable byte {\tt 0x80}--{\tt 0xFF} is converted to
a lone surrogate codepoint {\tt U+DC80}--{\tt U+DCFF}, which is then encoded to a 3-byte sequence by the UTF-8
algorithm. Upon receiving the string, reverse conversion or implementation-defined handling of the string is
performed.

Surrogates are codepoints reserved for UTF-16 encoding of codepoints above the Basic Multilingual Plane. They
are only valid as pairs in UTF-16, and not valid in UTF-8 at all. Therefore, a valid encoding cannot produce
a string which contains a lone surrogate codepoint, so there are no conflicts with this encoding scheme. Note
that this means that a string using this encoding scheme is not valid UTF-8. Implementations must be prepared
to handle potential UTF-8 decoding errors.

This encoding scheme does not cover all cases. Notably, in some encodings, bytes {\tt 0x00} through {\tt 0x7F}
can be parts of undecodable sequences. These are not supported for security reasons: it might be possible to
``smuggle in'' ASCII sequences such as `{\tt /..}', thus opening a new attack surface that must be checked by
implementations. See PEP~383~\cite{pep383} for full discussion. In NewTP, such bytes are instead to be
replaced by the Unicode replacement character {\tt U+FFFD}.

Also note that certain encodings, such as Big5, cannot be roundtrip-safely decoded to Unicode, because
multiple byte sequences map to the same Unicode codepoint. These are not supported by the core protocol.

%

\subsection{Path strings and file handles}

Paths and files in NewTP are referred to through file handles. The {\tt ASSIGN} command assigns a path string
to a file handle, and subsequent commands use the file handle as an argument, instead of the path string. The
purpose of this is to limit repeating of the potentially long path string.

Path strings are absolute and use the slash character (`{\tt /}') to separate path elements. Directory listing
returns names without full paths, and an absolute path name is constructed by combining directory path, slash, and
entry name from the listing. Paths do not start with leading slash -- a leading slash is considered to mean
that the first path element has zero length, which is invalid. Empty path string is allowed and refers to root
of the published filesystem.

File handle ID is specified as a 16-bit unsigned integer. That means that at most 65536 handles are available
to the client. Servers should provide as many handles as they can. At session initiation, server informs the
client about how many handles are available; these must be consecutive handles numbered 0--$({\tt max\_handles}
- 1)$. A conforming server must provide at least 16 handles.

File handles do not necessarily refer to valid filesystem objects -- for example, to create a new directory,
the client assigns the new path to a file handle and then issues a {\tt MAKEDIR} command on that handle.
A file handle does not become invalid when the object it is pointing to is removed, and it does not follow
externally moved files.\footnote{Although as a side-effect, the {\tt RENAME} command updates the file handle
with the new path.}

We wanted to avoid the necessity to open a file before writing, and the complexity associated with managing
``persistent'' open-file handles on the server. This means that several common POSIX usage patterns are not
directly supported: writing to a deleted or moved file recreates the original name instead of continuing to
write to the new location (or to the ``ghost'' version). These usage patterns can be emulated on the client if
necessary; replicating the POSIX semantics in concurrent scenarios is out of scope for NewTP.

%

\subsection{Metadata}

We define a set of basic attributes known about directory entries: entry type, size, creation time,
modification time, access rights etc. Each item is assigned a name, data type and a code. Recognized
attributes are listed in table~\ref{table:attributes}.

When requesting directory listing, the client specifies a sequence of codes, and specified metadata is
returned as part of each entry in the listing. Requested attributes from {\tt STAT} are specified in the same
way. Filesystem-like clients will request the full list, clients that want to save bandwidth can only ask for
attributes they are interested in.  Note that the full list is relatively long: three time fields and a size
field add up to 32 bytes, which is often longer than the entry name.

The {\tt SETATTR} call takes an attribute code and its new value. Only some attributes can be set, those are
marked as ``writable'' in the table. However, the fact that an attribute is writable does not mean that the
client has permission to set it.

Extended attributes and ACLs are not supported in the core protocol, but support can be added via extensions.
Extensions can also provide new attribute codes.

\begin{table}[p]
\begin{center}

\def\tline#1#2#3{
{\ttfamily #1} & {\ttfamily #2} & {\ttfamily #3}
}
\begin{tabular}{|lllcp{6cm}|}
	\hline
	Code & Name & Type & Writable & Value \\
	\hline
	\tline{0x00}{type}{byte} & No &
		Directory entry type: \newline
		{\tt 0x01} -- File \newline
		{\tt 0x02} -- Directory \newline
		{\tt 0x00} -- Other (e.g. device node) \newline
		{\tt 0xFF} -- Error entry
		\\
	\tline{0x01}{rights}{byte} & No &
		Bit mask of simplified access rights for~the current user account:\newline
		{\tt 0x01} -- Read permission \newline
		{\tt 0x02} -- Write permission \newline
		{\tt 0x03} -- Read and write permission
		\\
	\tline{0x03}{size}{uint64} & No & File size in bytes \\
	\tline{0x04}{device\_id}{uint32} & No &
		Arbitrary ID of logical device on which this entry resides.
		Entries within the same filesystem will have the same {\tt device\_id}
		and entries on different filesystmes will differ. No other guarantees
		are provided about the value.
		\\
	\tline{0x05}{links}{uint32} & No & Number of hard links to this entry \\
	\tline{0x06}{time\_access}{time\_t} & Yes & Last accessed time \\
	\tline{0x07}{time\_modified}{time\_t} & Yes & Last modification time \\

	\hline
	\multicolumn{5}{|c|}{\textit{POSIX-specific attributes}} \\
	\hline

	\tline{0x10}{posix\_mode}{uint32} & No &
		File type and permissions as expressed in the {\tt st\_mode} field
		of {\tt struct stat}.\newline
		TODO split type and permissions into separate fields?
		\\
	\tline{0x11}{time\_ctime}{time\_t} & Yes & POSIX {\tt ctime} \\
	\tline{0x12}{uid}{uint32} & Yes & User ID of owner \\
	\tline{0x13}{gid}{uint32} & Yes & Group ID of owner \\

	\hline
	\multicolumn{5}{|c|}{\textit{Windows-specific attributes}} \\
	\hline

	\tline{0x20}{attributes}{uint32} & Yes & Windows file attributes \\
	\tline{0x21}{time\_created}{time\_t} & Yes & Entry creation time \\

	\hline
\end{tabular}

\end{center}
\caption{Attribute codes, types and values}
\label{table:attributes}
\end{table}

%

\subsection{Extension mechanism}
\label{ssec:extensions}

\begin{samepage}
Each extension field is sent in the following format:
\begin{description}[parsep=1pt]
	\ttitem{byte extension\_code} \hfill \\
		8-bit extension code. Must not be zero.
	\ttitem{uint16 extension\_name\_len} \hfill \\
		Length of {\tt extension\_name}
	\ttitem{string extension\_name} \hfill \\
		Name of the extension
\end{description}
\end{samepage}

%%

\section{Communication scheme}

After establishing the TCP connection and successful TLS handshake, the client starts session initialization,
through which it agrees on a common version with the server. If the session was initialized successfully,
client starts the SASL authentication process. If that is successful, client can start sending commands.

%

\subsection{Session initalization}

\begin{samepage}
After the TLS session is established, client introduces itself with the following packet:
\begin{description}[parsep=1pt]
	\ttitem{string newtp} \hfill \\
		Fixed ASCII string ``{\tt NewTP}''
	\ttitem{uint16 length} \hfill \\
		Length of payload
	\ttitem{uint16 version} \hfill \\
		Protocol version
\end{description}

Here, ``payload'' refers to everything that comes after it. In this case, payload length is 2 (size of the
{\tt version} field). Protocol version is 1. We specify the payload length for extensibility: in a future
version, client might be sending more info in the initial packet. In version 1, only the version number is
sent.
\end{samepage}

\begin{samepage}
Server replies with the following packet:
\begin{description}[parsep=1pt]
	\ttitem{string newtp} \hfill \\
		Fixed ASCII string ``{\tt NewTP}''
	\ttitem{uint16 length} \hfill \\
		Length of payload
	\ttitem{uint16 version} \hfill \\
		Protocol version.
	\ttitem{uint16 max\_handles} \hfill \\
		Number of available file handles
	\ttitem{uint16 max\_opendirs} \hfill \\
		Number of directories available for simultaneous listing
	\ttitem{uint16 authstr\_len} \hfill \\
		Length of {\tt authstr}
	\ttitem{string authstr} \hfill \\
		List of supported SASL authentication mechanisms, separated by ASCII spaces ({\tt 0x20})
	\ttitem{uint16 num\_extensions} \hfill \\
		Number of extension fields TODO number or length?
	\ttitem{data extensions} \hfill \\
		Extension fields
\end{description}
\end{samepage}

Server should reply with a protocol version that is either the highest version supported, or equal to client
protocol version, whichever is lower. That means that if the server supports a version higher than the client,
it should downgrade to the client version. Server can only report higher version than the client if it is not
backwards-compatible with client version. In that case, client should probably abort the connection attempt.

If the client version is higher than the server version, client should either use the protocol version
supplied by server, or abort the connection attempt.

Format of extension fields is described in section \ref{ssec:extensions} Extension mechanism.

This concludes the session initialization. The client can now select an authentication mechanism and proceed
to the next step. If the server advertises the {\tt ANONYMOUS} mechanism, the client should select it, unless
the user indicates otherwise.

%

\subsection{SASL authentication}

This section of the work provides all relevant information in conformance with RFC~4422~\cite{rfc4422}
section~4 (Protocol Requirements). GSS-API service name is ``{\tt newtp}''.\footnote{The name is not
registered with IANA, so we do not technically conform to RFC~2743~\cite{rfc2743} requirements, and
transitively to RFC~4422 requirements either. For the purposes of this work, we consider this informal
conformance sufficient, seeing as hardly anyone will be using NewTP with GSS-API authentication in the
foreseeable future. At the time of this writing, the name ``{\tt newtp}'' is not allocated in the IANA service
registry.} NewTP does not allow multiple authentication, so any authentication exchange can be aborted by
disconnecting. This version of the protocol does not support separate authentication and authorization
identities, so authorization identity string should always be empty.

Mechanism negotiation is covered by the previous subsection. The core protocol does not allow the client to
rediscover available authentication mechanism after the authentication step is completed. We consider this
acceptable, because the session is already secured by TLS. For the same reason, the protocol is not using SASL
security layers even if they are available.

Scheme of the authentication exchange is described in RFC~4422. The client initiates the exchange, after which
the server can reply with a challenge and client reacts to that by sending a response. This can be repeated
zero or more times. At the end of the exchange, in reply to last client response, server sends an outcome
packet.  If the outcome is success, client is authenticated and can start sending commands. If the outcome is
failure, server will disconnect the client.

Client initiates the authentication exchange by sending one of the following packets:
\begin{enumerate}

\begin{samepage}
\item Initiation with mechanism name, {\it without} initial response
\begin{description}[parsep=1pt]
	\ttitem{string auth\_init} \hfill \\
		Fixed ASCII string ``{\tt A0}''
	\ttitem{uint16 length} \hfill \\
		Length of payload (in this case, only the mechanism name)
	\ttitem{string mechanism} \hfill \\
		Name of the selected mechanism
\end{description}
\end{samepage}

\begin{samepage}
\item Initiation with mechanism name, {\it with} initial response
\begin{description}[parsep=1pt]
	\ttitem{string auth\_init} \hfill \\
		Fixed ASCII string ``{\tt A1}''
	\ttitem{uint16 length} \hfill \\
		Length of payload
	\ttitem{uint16 mechanism\_len} \hfill \\
		Length of mechanism name
	\ttitem{string mechanism} \hfill \\
		Name of the selected mechanism
	\ttitem{uint16 response\_len} \hfill \\
		Length of initial response
	\ttitem{data response} \hfill \\
		Initial response
\end{description}
\end{samepage}

\end{enumerate}

\begin{samepage}
Server challenge packet format is as follows:
\begin{description}[parsep=1pt]
	\ttitem{string auth\_challenge} \hfill \\
		Fixed ASCII string ``{\tt AC}''
	\ttitem{uint16 length} \hfill \\
		Length of challenge
	\ttitem{data challenge} \hfill \\
		Contents of challenge
\end{description}
\end{samepage}

\begin{samepage}
Client response packet format is as follows:
\begin{description}[parsep=1pt]
	\ttitem{string auth\_response} \hfill \\
		Fixed ASCII string ``{\tt AR}''
	\ttitem{uint16 length} \hfill \\
		Length of response
	\ttitem{data response} \hfill \\
		Contents of response
\end{description}
\end{samepage}

At the end of the exchange, server will return an outcome in one of two ways:
\begin{enumerate}

\begin{samepage}
\item Outcome of authentication exchange, {\it without} additional data
\begin{description}[parsep=1pt]
	\ttitem{string auth\_outcome} \hfill \\
		Fixed ASCII string ``{\tt AF}'' (for ``Auth Finished'')
	\ttitem{uint16 length} \hfill \\
		Length of payload (in this case, 1)
	\ttitem{byte result} \hfill \\
		Result code
\end{description}
\end{samepage}

\begin{samepage}
\item Outcome {\it with} additional data
\begin{description}[parsep=1pt]
	\ttitem{string auth\_outcome} \hfill \\
		Fixed ASCII string ``{\tt AD}'' (for ``Auth outcome with Data'')
	\ttitem{uint16 length} \hfill \\
		Length of payload
	\ttitem{byte result} \hfill \\
		Result code
	\ttitem{uint16 adata\_len} \hfill \\
		Length of additional data
	\ttitem{data adata} \hfill \\
		Additional data
\end{description}
\end{samepage}

\end{enumerate}

TODO define codes for success and failure

%

\subsection{Request and response packets}

Request header contains command id, handle id and operation id, plus length of payload. Payload may contain
further arguments for the command. Response header contains payload length, operation id and return code.
Smaller than 0x80 is OK, 0x80 and above is error.  The codes have predefined meanings.

%

\subsection{Communication scheme}

Client starts by sending hello, then it authenticates, then it fires commands and gets responses.  In the
first version, responses come in the same order as commands. There is no QUIT command, client simply
disconnects and server discards all (most?) state. When establishing the session, different packet format is
used, this way a future version only needs to keep the hello message and redefine other packets.

%

\subsection{Example session}

TODO -- only a table?

%%

\section{List of commands}

Complete list of core commands, with descriptions, arguments, etc.

\subsection{ASSIGN}

\subsection{STAT}

\subsection{SETATTR}

\subsection{STATVFS}

\subsection{READ}

\subsection{WRITE}

\subsection{TRUNCATE}

\subsection{DELETE}

\subsection{RENAME}

\subsection{MAKEDIR}

\subsection{REWINDDIR}

\subsection{READDIR}


%%

\section{Result codes}

TODO -- only a table?

%%

\section{Extensions}

this section describes the concept of the extension mechanism and lists some extensions

\subsection{Asynchronous operations}

Commands to fire off an operation (equivalent of some commands, plus on-server copy, recursive delete,
cross-filesystem move etc.) on a handle, command to monitor progress (depends on the command, by default
"none/in progress/finished"), command to abort.

\subsection{Extended attributes}

Commands to read and set extended attributes.

\subsection{Links}

Separate extensions for hardlinks and softlinks? Each with one command: link this path to this new name.

\subsection{Replay}

Remember results of certain operations in the main process and replay them to whoever asks.
