% vim: tw=110:fo=n1lt:nosmartindent

\chapter{Design of the new protocol}

We have developed a new file transfer protocol called NewTP (as a play on FTP, the original file transfer
protocol). This chapter describes the design decisions that went into the development, how the protocol
operates and what features it provides. We also describe how the extension mechanism works and define several
extensions.

%%

\section{Overview}

NewTP is a binary application protocol running on an encrypted channel with ordered and reliable delivery. It
is designed with TCP + TLS in mind; for this version, use of TLS 1.2 or later is mandatory. Communication is
split into packets with a fixed-length header and at most 64 kB of data. Client initiates all traffic. For
every client request packet, server must send exactly one reply packet, and it must send the replies in the
order in which it received the requests.

After an initial handshake, client must authenticate itself using the SASL protocol~\cite{rfc4422}. Where
appropriate, anonymous authentication mechanism will be available. A conforming implementation must support at
least anonymous and password-based authentication.\footnote{That is, {\tt ANONYMOUS} and {\tt PLAIN} SASL
mechanisms.}

Once the session is established, client sends requests and receives replies in a common format. Commands
usually operate on filesystem objects refered to by a file handle. Before use, client must set up the file
handle by assigning a path string to it. Requests specify an arbitrary ID that is repeated in the reply;
although this version of the protocol does not allow it, future revisions might let the server reorder
replies, in which case the request ID will be used to match replies to corresponding requests.

Core NewTP command set consists of ranged read, ranged write with implicit file creation, truncate operation,
directory listing that includes selected metadata attributes, creating directories, delete and rename/move
operations, metadata querying and manipulation. Additional commands can be added through an extension
mechanism without changing the protocol.

%%

\section{Design decisions}

The protocol is intended as a lightweight file transfer protocol with some filesystem-like features. We wanted
to limit its feature set for ease of implementation, provide reasonable performance on high-latency networks,
ensure cross-platform interoperability, and make the protocol secure by default.

%

\subsection{Supported scenarios}

NewTP is designed with three main use cases in mind.

%

\subsubsection{Local fileserver}

In this scenario, the NewTP server is placed on a private local network or a VPN and provides a shared
document and multimedia store for its users. The network is considered a trusted environment, and the server
assumes that clients allowed to connect to the network are automatically entitled to access the document
store.  Encryption is not essential and authentication is completely unnecessary. Filesystem-like features are
desirable for operating system integration, but advanced locking and conflict resolution features are not
required, because conflicts will usually be resolved on the human level. This is the case for file servers or
media centers on home networks. Users in this scenario don't necessarily have technical background, so neither
the protocol nor its implementations should place any barriers to ease of use.

%

\subsubsection{Temporary share on a public network}

Users connected to the same network want to quickly exchange files. One of them sets up a NewTP server on
their computer, the others connect to it and download the published files or upload their own data. After all
transfers are done, the server is shut down. The network is assumed to be untrusted -- it might be an open WiFi
in a restaurant or a shared building-wide LAN -- so we require encryption, authentication and MitM protection.
However, the users are assumed to have a communication side-channel, such as close physical proximity, so
there is no need for any sort of PKI. The emphasis is on the ability to set up a server quickly, without
complicated supporting infrastructure. Ideally, both server and client software are implemented as portable
executables that the users can download and run with minimum of configuration. Filesystem-like features are
not required, because the users only need upload, download and directory manipulation capabilities.

%

\subsubsection{Shared Internet fileserver}

A web hosting or cloud storage provider sets up a NewTP server connected to the Internet. Clients of the
provider are issued credentials and use the NewTP protocol to access their files. Obviously, encryption and
MitM protection is required. However, in this scenario, it is more difficult to verify authenticity of the
server. Its certificate must either be verifiable through a PKI, or a through a side-channel such as physical
mail.  Implementations should also check for certificate changes.

A single server will be serving multiple users, so the protocol must provide user accounts and the
implementation will publish different parts of the filesystem based on which user account is authenticated.
Users will be using both dedicated NewTP clients and operating system integration, so filesystem-like
features, although not strictly required, are strongly desirable.

%

\subsection{Simplicity}

Simplicity means different things to different people and in different contexts. In case of NewTP, we want to
ensure that the protocol is simple to implement and use properly -- or, to put it differently, make it more
difficult to write a buggy implementation than a correct one. To this end, we designed the protocol with
a highly regular communication scheme. Different values of message arguments should not lead to unexpected
behaviors, and errors are easy to detect.  The core feature set is small and variability of commands is
limited. Individual commands mostly correspond to how the operating system works with filesystems, so each
command can usually be implemented with one or two system calls on the server. On the client, it is easy to
replicate common file operations with calls over the network. In difficult cases, we opt for less complex
solutions that work well for our supported scenarios, even if they do not perfectly cover corner cases.

Simplicity is also the reason for choosing TCP as the transport layer. This way, the protocol does not need to
concern itself with lost or out-of-order packets.

%

\subsection{Secure by default}

Protocols designed before the rise of Internet usually provide encryption as an optional feature. This leads
to widespread practice of using unencrypted connections on insecure public networks. We want to avoid this
practice with NewTP. Therefore, the protocol mandates use of TLS 1.2 or later for every connection.
Furthermore, we recommend that implementations use the highest available version of TLS at a given time, and
disable weak ciphersuites.

Especially in the ``local fileserver'' and ``temporary share'' scenarios, it is unrealistic to expect that
users would obtain a certificate from a trusted certificate authority, much less roll their own.
Implementations must allow self-signed certificates by default, and for ease of use, server applications
should generate their own certificates automatically. To ensure that attacker does not impersonate
a legitimate server with a brand new self-signed certificate, clients should remember certificates on first
connection and warn the user if the certificate has changed.\footnote{This practice is known as {\it
certificate pinning}.}

We attempted to design NewTP so that implementing it does not easily lead to buffer overflows.  Packet size is
limited to 64 kB, so every packet can fit into a fixed-size buffer. The protocol is binary and most packet
structures have a predefined size. Strings are not null-terminated, so the implementation is forced to use the
corresponding length field. Same is true for lists of structs. Where possible, length information is not
duplicated so implementations cannot be fooled by a mismatch. Simplicity of the protocol also means that the
client can't easily tie up disproportionately huge amounts of server processing power with a small number
of~requests.

%

\subsection{Low latency}

Given that the protocol is using TLS, establishing a connection takes a nontrivial amount of time. This is
even more true on high-latency networks like GPRS/EDGE. We want to make operation on such networks as painless
as possible. That means good support for interleaving of operations on a single connection, and reducing size
of protocol messages.

The choice of a binary protocol results in smaller messages. The short maximum packet length means that in the
ideal case, after a new operation is inserted into the outgoing stream, the client downloads at most 64 kB of
data before receiving a response for the newly inserted operation. In practice, clients on high-latency
networks will batch requests, so that when the new operation is inserted, it has to wait before the whole
preceding batch is processed. However, there is room for implementations to perform flow control and send
batched messages only as fast as they can receive responses, in which case it is possible to insert commands
midway through.

This sort of interleaving rules out long operations, which is helpful even on fast networks. It means that it
is easy to implement a responsive filesystem emulation on top of NewTP.

To make the amount of transfered data even smaller, implementers may choose to enable TLS compression. Be
advised, though, that encryption and compression interact in nontrivial ways. Size of data transfers provides
information about compression ratio of data being transfered, which may under some circumstances enable
a successful attack on the encryption. The paper~\cite{kelsey2002} examines the issue in detail.

Transfer overhead works out to 24 bytes per 64 kB when using maximum possible packet size. To put this in
perspective, when downloading 2 GB of data at top speed, protocol overhead will consume additional 786 kB.
This is perfectly acceptable.

%

\subsection{Authentication is optional}

In the ``local fileserver'' scenario, we don't want the clients to authenticate. In the ``temporary share'',
the authentication is supposed to be short and simple, probably based on a passphrase. In the ``Internet
fileserver'' scenario, strongest possible authentication is required, possibly including client certificates
or two-factor authentication.

We decided to implement authentication through the SASL protocol. This allows us to use a wide range of
authentication mechanisms, ranging from anonymous access, to plaintext usernames and password, to digest-based
authentication. Also, with SASL, new authentication mechanisms can be supported by implementations without
changing the NewTP protocol. Reusing an existing technology (SASL is implemented by a number of widely
available libraries) also reduces work for implementers.

The fact that SASL supports anonymous authentication allows us to make the SASL process mandatory, while still
technically keeping authentication optional. This again simplifies the protocol.

%

\subsection{Concurrency is out of scope}

NewTP is intended to service use cases with minimal interactions between users and negligible amounts of
conflicts. Because of that, we decided not to put any locking mechanisms into the protocol. Locking is
a decidedly complex problem in itself, and it is not a problem that NewTP is trying to solve.

We take concurrency issues into consideration and make reasonable attempts to prevent or solve them. We expect
that locking mechanisms could be implemented as protocol extensions, either by third parties or in a future
revision of the protocol. In general, however, we consider reliable concurrency to be out of scope, and
recommend using a different protocol for scenarios that require it.

%

\subsection{Caching policy}

In this version of the protocol, clients are fully responsible for managing their caches.  Depending on the
application, a client should periodically check freshness of relevant data.  For filesystem emulation, clients
should check cache freshness every time a file is opened, and perform server write when the file is closed.
In addition, it is advisable to refresh directory cache at reasonable intervals, e.g., once a minute.

In order for the server to take part in client cache management, the protocol would need a mechanism to send
unsolicited updates to clients. We considered adding such mechanism -- this ability might be useful beyond
cache management, e.g., to signal upcoming server shutdown. However adding unsolicited updates would break the
simplicity of client-initiated-traffic model. Therefore, we decided to leave it out of this version.

A possible solution for a future revision is to allow the server to reorder client requests. Clients that are
interested in server updates would then send a special command at start of session, and the server would
respond to this command later, when updates became available.\footnote{This technique is known as {\it long
polling} and is widely used in Web applications, because the HTTP protocol also lacks the capability to send
unsolicited updates.}

%

\subsection{Non-idempotent operations}

Since native locking is not part of the protocol, we make an attempt to minimize problems with directory-based
locking and mitigate potential issues with non-idempotent operations. To this end, we have designed
a ``Replay'' extension. After establishing a session and authenticating, the client can ask for a unique
session token. If the connection is lost, the client can reconnect, and after a successful authentication, ask
for a replay of the session identified by that token. The server will reply with results for the last few
non-idempotent operations recorded under the provided token. If the session is still alive on the server, it
will be terminated to prevent late delivery of further commands. This way the client can resume after the last
command that was successfully received by the server.

Security of this extension is ensured by using tokens that are long enough to prevent guessing, and only
providing the replay to the same user account.

%%

\section{Building blocks}

This section describes various technical details pertaining to design and implementation of NewTP.

%

\subsection{Packet format notation}

Packets are described in a C-style format, data type preceding field name. Various packets use data types
defined as follows. All numeric fields are stored in network byte order (big-endian). String fields are not
null-terminated and can include null bytes.

\def\ttitem#1{ \item[\ttfamily #1] }
\begin{description}[leftmargin=1.7cm,style=sameline]
	\ttitem{byte} An 8-bit value (octet). Bytes represent command codes, result codes and other fields
		where the value is one of a fixed set of possibilities. The values are written out in
		hexadecimal notation, e.g., {\tt 0x07}.
	\ttitem{uint16} Unsigned 16-bit integer
	\ttitem{uint32} Unsigned 32-bit integer
	\ttitem{uint64} Unsigned 64-bit integer
	\ttitem{time\_t} Unsigned 64-bit integer, representing time in microseconds since the start of UNIX
		epoch (January 1, 1970, 0:00:00 UTC)
	\ttitem{data} Byte sequence of arbitrary length. Information about its length will be provided
		separately -- either in a different field, or obtained by a~calculation. Where unspecified, it
		is assumed that the {\tt data} field covers all remaining data in the packet.
	\ttitem{string} Unsigned 16-bit length field, followed by a byte sequence of that length. Essentially,
		{\tt uint16} followed by {\tt data}.
\end{description}

%

\subsection{Path string encoding}

All filenames and path strings must be encoded as UTF-8. Clients and servers must perform transcoding from
system-native filename encoding to UTF-8 and back.

To support filenames that are undecodable in the system encoding, NewTP uses a roundtrip-safe encoding scheme
described in PEP~383~\cite{pep383}. In this scheme, an undecodable byte {\tt 0x80}--{\tt 0xFF} is converted to
a lone surrogate codepoint {\tt U+DC80}--{\tt U+DCFF}, which is then encoded to a 3-byte sequence by the UTF-8
algorithm. Upon receiving the string, reverse conversion or implementation-defined handling of the string is
performed.

Surrogates are codepoints reserved for UTF-16 encoding of codepoints above the Basic Multilingual Plane. They
are only valid as pairs in UTF-16, and not valid in UTF-8 at all. Therefore, a valid encoding cannot produce
a string which contains a lone surrogate codepoint, so there are no conflicts with this encoding scheme. Note
that this means that a string using this encoding scheme is not valid UTF-8. Implementations must be prepared
to handle potential UTF-8 decoding errors.

This encoding scheme does not cover all cases. Notably, in some encodings, bytes {\tt 0x00} through {\tt 0x7F}
can be parts of undecodable sequences. These are not supported for security reasons: it might be possible to
``smuggle in'' ASCII sequences such as `{\tt /..}', thus opening a new attack surface that must be checked by
implementations. See PEP~383 for full discussion. In NewTP, such bytes are instead to be replaced by the
Unicode replacement character {\tt U+FFFD}.

Also note that certain encodings, such as Big5, cannot be roundtrip-safely decoded to Unicode, because
multiple byte sequences map to the same Unicode codepoint. These are not supported by the core protocol.

%

\subsection{Path strings and file handles}
\label{ssec:paths}

Paths and files in NewTP are referred to through identifiers called {\it file handles}. The purpose of this is
to reduce transfer sizes and simplify packet structure. In order to eliminate a round-trip on file handle
assignment, clients choose their own file handles.\footnote{This is a common technique for reducing latency;
for instance, the X Window protocol does the same with resource identifiers.~\cite{xwindow}} The {\tt ASSIGN}
command specifies a file handle and a path string. This relation is stored by the server, and subsequent
commands use the file handle to represent this path string.

Path strings are absolute and use the slash character (`{\tt /}') to separate path elements. Empty path
elements, path elements `{\tt .}' and `{\tt ..}' must not be part of the path. Directory listing returns names
without full paths, and an absolute path name is constructed by combining directory path, slash, and entry
name from the listing. Empty path string is allowed and refers to root of the published filesystem. Combining
empty path with a slash and a root entry name results in path with a leading slash -- therefore, leading slash
is mandatory. Trailing slash is forbidden; in particular, path string ``{\tt /}'' does not refer to the root
directory and is invalid.

File handle ID is specified as a 16-bit unsigned integer. That means that at most 65536 handles are available
to the client. Servers should provide as many handles as they can. At session initiation, server informs the
client about how many handles are available; these must be consecutive handles numbered 0--$({\tt max\_handles}
- 1)$. A conforming server must provide at least 16 handles. When the session starts, every available handle is
set to empty path.

File handles do not necessarily refer to valid filesystem objects. For example, to create a new directory,
the client assigns the new path to a file handle and then issues a {\tt MAKEDIR} command on that handle.
A file handle does not become invalid when the object it is pointing to is removed, and it does not follow
externally moved files.\footnote{Although as a side-effect, the {\tt RENAME} command updates the file handle
with the new path.}

We wanted to avoid the necessity to open a file before writing, and the complexity associated with managing
``persistent'' open-file handles on the server. This means that several common POSIX usage patterns are not
directly supported: writing to a deleted or moved file recreates the original name instead of continuing to
write to the new location (or to the ``ghost'' version). These usage patterns can be emulated on the client if
necessary; replicating the POSIX semantics in concurrent scenarios is out of scope for NewTP.

%

\begin{table}
\begin{center}

\def\tline#1#2#3{
{\ttfamily #1} & {\ttfamily #2} & {\ttfamily #3}
}
\begin{tabular}{lllcp{6cm}}
	\hline
	Code & Name & Type & Writable & Value \\
	\hline
	\tline{0x00}{type}{byte} & No &
		Directory entry type: \newline
		{\tt 0x01} -- File \newline
		{\tt 0x02} -- Directory \newline
		{\tt 0x00} -- Other (e.g., device node) \newline
		{\tt 0xFF} -- Error entry
		\\
	\tline{0x01}{rights}{byte} & No &
		Simplified access rights:\newline
		{\tt 0x01} -- Read permission \newline
		{\tt 0x02} -- Write permission \newline
		{\tt 0x03} -- Read and write permission
		\\
	\tline{0x02}{size}{uint64} & No & File size in bytes \\
	\tline{0x03}{device\_id}{uint32} & No & ID of the filesystem tree\footnotemark[1] \\
	\tline{0x04}{links}{uint32} & No & Number of hard links to this entry \\
	\tline{0x05}{atime}{time\_t} & Yes & Last access time \\
	\tline{0x06}{mtime}{time\_t} & Yes & Last modification time \\

	\hline
	\multicolumn{5}{c}{\textit{POSIX-specific attributes}} \\
	\hline

	\tline{0x10}{posix\_type}{byte} & No &
		POSIX file type:\footnotemark[2] \newline
		{\tt 0x01} -- Named pipe (FIFO) \newline
		{\tt 0x02} -- Character device \newline
		{\tt 0x04} -- Directory \newline
		{\tt 0x06} -- Block device \newline
		{\tt 0x08} -- Regular file \newline
		{\tt 0x0A} -- Symbolic link \newline
		{\tt 0x0C} -- Socket
		\\
	\tline{0x11}{perms}{uint16} & Yes & File permission bits\footnotemark[3] \\
	\tline{0x12}{ctime}{time\_t} & No & POSIX {\tt ctime} \\
	\tline{0x13}{uid}{uint32} & Yes & User ID of owner \\
	\tline{0x14}{gid}{uint32} & Yes & Group ID of owner \\

	\hline
	\multicolumn{5}{c}{\textit{Windows-specific attributes}} \\
	\hline

	\tline{0x20}{attributes}{uint32} & Yes & Windows file attributes \\
	\tline{0x21}{cr\_time}{time\_t} & Yes & Entry creation time \\

	%\hline
\end{tabular}
\end{center}

{\footnotesize \footnotemark[1] The device ID is arbitrary. Entries within the same filesystem will have the
same {\tt device\_id} and entries on different filesystems will have different values. No other guarantees are
provided.}

{\footnotesize \footnotemark[2] These values directly correspond to file type flags of {\tt st\_mode} field in
{\tt struct stat}. The C~expression {\tt (posix\_type << 12)} can be tested with {\tt S\_IS*} macros.}

{\footnotesize \footnotemark[3] This field corresponds to permission bits of {\tt st\_mode} field in {\tt
struct stat}, including setuid, setgid and sticky bits. The values can be tested and set with {\tt S\_I*}
permission flags.}

\caption{Attribute codes, types and values}
\label{table:attributes}
\end{table}

%

\subsection{Metadata}

We define a set of basic attributes known about directory entries: entry type, size, creation time,
modification time, access rights etc. Each item is assigned a name, data type and a code. Recognized
attributes are listed in table~\ref{table:attributes}.

When requesting directory listing, the client specifies a sequence of codes, and specified metadata is
returned as part of each entry in the listing. Requested attributes for {\tt STAT} are specified in the same
way. Filesystem-like clients will request the full list, clients that want to save bandwidth can only ask for
attributes they are interested in.  Note that the full list is relatively long: three time fields and a size
field add up to 32 bytes, which is often longer than the entry name.

The {\tt SETATTR} call takes an attribute code and its new value. Only some attributes can be set, those are
marked as ``writable'' in the table. The fact that an attribute is writable does not necessarily mean that the
client has permission to set it.

Extended attributes and ACLs are not supported in the core protocol, but support can be added via extensions.
Extensions can also provide new attribute codes.

%

%%%
\def\pkfield#1#2#3{ {\ttfamily #1} & {\ttfamily #2} & #3 \\ }
\newcommand{\beginpk}[1][p{3.2cm} p{6.8cm}] {
	\begin{center}
	\begin{tabular}{l #1}
}
\def\endpk{
	\end{tabular}
	\end{center}
}

\subsection{Extension mechanism}
\label{ssec:extensions}

At session intialization, server sends a list of available extensions. Each extension is identified by a name,
which must be unique, and an extension code, which can be dynamically assigned by the server. That means that
the same extension can have different codes on different servers, or even between one session and another.

Extension code {\tt 0x00} is reserved for core protocol commands. Extension code~{\tt 0xFF} is reserved for
session initialization and SASL authentication messages. Neither can be used in the extension list.  Extension
codes {\tt 0x01}--{\tt 0x30} are reserved for standard extensions. Standard extensions will be mentioned
in~the~extension list if they are present, but their code is fixed and guaranteed to be the same on all
implementations.  Server must not allocate extension codes in this range.

Server sends the extension list as a sequence of fields in the following format:
\beginpk
	\pkfield{byte}{extension\_code}{Extension code}
	\pkfield{string}{extension\_name}{ASCII-encoded extension name}
\endpk

Extensions can define new protocol commands and result codes, which are then referred to by the extension
code. Extensions can also add new file attributes. Attribute codes do not use the extension code, so extension
authors must ensure that their attribute codes do not conflict with another extension. Extensions may not modify
existing commands or replies.

%%

\section{Communication scheme}

After establishing a TLS connection, the client starts session initialization, through which it
agrees on a common version with the server. If the session is initialized successfully, client starts the
SASL authentication process. If that is successful, client can start sending commands.

Client can disconnect at any time. If the server detects client disconnect, it destroys all associated state,
except for replay cache described in the Replay extension. Unprocessed commands are discarded and long-running
operations in progress are aborted.

%

\subsection{Framing}

Every packet consists of a fixed-length {\it header} and a variable-length {\it payload}. Last field of the
header is always {\tt uint16 length}, which denotes length of the payload. After reading the header, an
implementation should retrieve exactly {\tt length} bytes from the data stream to process the whole packet. If
the packet is discarded, the implementation can resume parsing the data stream at that position and safely
find the start of the next packet.

Length can be zero, indicating an empty packet. In that case, another packet header follows immediately.

Implementations must check that contents of the payload do not stretch beyond the end of the packet. Notably,
if the payload contains variable-length fields with size specified inline, these must fit inside the packet.
But even if the implementation only expects fixed-length fields, it must check whether the packet is long
enough to contain them. If the expected or calculated length of payload exceeds {\tt length}, the packet is
malformed and should be discarded.\footnote{If the server discards a packet, it must inform the client.} If
the expected or calculated length of payload is smaller than {\tt length}, the implementation must ignore the
remaining data -- these may contain fields that the implementation does not understand.

Only the payload is framed through the {\tt length} field, not the header. We assume that if a communicating
party does not understand the fixed-format header, the difference in protocol versions is too big to allow any
sort of meaningful communication anyway.

%

\subsection{Request and reply packets}

Except for the initial magic strings, all communication uses uniform request and reply packets.

Request packets, sent by the client, use the following header:
\beginpk[p{2.7cm} p{7.3cm}]
	\pkfield{uint16}{request\_id}{Arbitrary request ID}
	\pkfield{byte}{extension}{Extension code, {\tt 0x00} for core command}
	\pkfield{byte}{command}{Command code}
	\pkfield{uint16}{handle}{File handle}
	\pkfield{uint16}{length}{Length of payload}
\endpk

Every request packet specifies a file handle. Certain commands, session initialization packets, do not use
a file handle argument. In such case, value of the {\tt handle} field is ignored.

Reply packets, sent by the server, use the following header:
\beginpk[p{2.7cm} p{7.3cm}]
	\pkfield{uint16}{request\_id}{Request ID from corresponding request}
	\pkfield{byte}{extension}{Extension code, {\tt 0x00} for core result code}
	\pkfield{byte}{result}{Result code}
	\pkfield{uint16}{length}{Length of payload}
\endpk

Server must send replies in the order of received requests. Each reply must copy the request ID of
corresponding request. Request ID s are arbitrarily selected by the client, and the server should not use them
for any other purpose than matching replies to requests.

Payload of request packet contains arguments for the command, data to be written etc. Payload of reply
packet contains attribute query results, data read, details of error etc. Descriptions of commands specify
payload formats for both requests and replies to that command.

%

\subsection{Session initalization}

After the TLS session is established, client sends the following 7-byte magic sequence:
\beginpk
	\pkfield{data}{newtp}{Fixed ASCII string ``{\tt NewTP}''}
	\pkfield{uint16}{version}{Protocol version}
\endpk

Protocol version is 1. After the magic string, client immediately sends a request packet with extension
code {\tt 0xFF} and command code {\tt 0x00}. In a future version, this packet might contain introductory data
about the client. For now, no introductory data are necessary, so the packet is empty.

After receiving client introduction, the server introduces itself with the same magic sequence, followed by
a reply packet. This reply packet sets extension code {\tt 0xFF} and result code {\tt 0x00}. Any other result
code indicates that session negotiation has failed and connection must be terminated.

The reply packet carries the following payload:
\beginpk
	\pkfield{uint16}{max\_handles}{Number of available file handles}
	\pkfield{uint16}{max\_opendirs}{Number of directories available for simultaneous listing}
	\pkfield{string}{platform}{Platform string}
	\pkfield{string}{authstr}{List of supported SASL authentication mechanisms, separated by ASCII spaces ({\tt 0x20})}
	\pkfield{uint16}{num\_extensions}{Number of extension fields}
	\pkfield{data}{extensions}{Extension fields}
\endpk

Platform string can be ``{\tt posix}'' or ``{\tt windows}'', this specifies which platform-specific attributes
will be available. If the client does not recognize the platform string, it can only use the
platform-independent attributes.

Server should reply with a protocol version that is either the highest version supported, or equal to client
protocol version, whichever is lower. That means that if the server supports a version higher than the client,
it should downgrade to the client version. Server can only report higher version than the client if it is not
backwards-compatible with client version. In that case, client should probably abort the connection attempt.

If the client version is higher than the server version, client should either use the protocol version
supplied by server, or abort the connection attempt.

Format of extension fields is described in section~\ref{ssec:extensions}.

This concludes the session initialization. The client can now select an authentication mechanism and proceed
to the next step. If the server advertises the {\tt ANONYMOUS} mechanism, the client should select it, unless
the user indicates otherwise.

%

\subsection{SASL authentication}

This section of the work provides all relevant information in conformance with RFC~4422~\cite{rfc4422}
section~4 (Protocol Requirements). GSS-API service name is ``{\tt newtp}''.\footnote{The name is not
registered with IANA, so we do not technically conform to RFC~2743~\cite{rfc2743} requirements, and
transitively to RFC~4422 requirements either. For the purposes of this work, we consider this informal
conformance sufficient, seeing as hardly anyone will be using NewTP with GSS-API authentication in the
foreseeable future. At the time of this writing, the name ``{\tt newtp}'' is not allocated in the IANA service
registry.} NewTP does not allow multiple authentication, so any authentication exchange can be aborted by
disconnecting. This version of the protocol does not support separate authentication and authorization
identities, so authorization identity string should always be empty.

Mechanism negotiation is covered by the previous subsection. The core protocol does not allow the client to
rediscover available authentication mechanisms after the authentication step is completed. We consider this
acceptable, because the session is already secured by TLS. For the same reason, the protocol is not using SASL
security layers even if they are available.

Scheme of the authentication exchange is described in RFC~4422. The client initiates the exchange, after which
the server can reply with a challenge and client reacts to that by sending a response. This can be repeated
zero or more times. At the end of the exchange, in reply to last client response, server sends an outcome
packet.  If the outcome is success, client is authenticated and can start sending commands. If the outcome is
failure, server will disconnect the client.

SASL authentication packets follow the uniform packet format. Extension code is always {\tt 0xFF} and file
handle field is ignored. Contents of challenges and responses are transmitted as pure data, i.e., no
additional encoding (such as base64) is applied.

Note that the SASL terminology does not correspond to NewTP's communication scheme: the client is sending
NewTP {\it request} packets that contain SASL {\it responses}, and the server responds to these with NewTP
{\it reply} packets carrying SASL {\it challenges}. In the following text, the words ``request'', ``reply'',
``challenge'' and ``response'' denote concepts from the corresponding protocol, as outlined in this paragraph.

Client initiates the authentication exchange by sending one of the following request packets:

\begin{enumerate}

\item Initiation with mechanism name, {\it without} initial response. Command code is {\tt 0x10 SASL\_START}.
Payload is a single {\tt data} field, containing name of the selected mechanism.

\item Initiation with mechanism name, {\it with} initial response. Command code is {\tt 0x11 SASL\_START\_OPT}.
Payload is in the following format:

\beginpk
	\pkfield{string}{mechanism}{Name of the selected mechanism}
	\pkfield{string}{response}{Initial response}
\endpk
\end{enumerate}

The server reply has one of several possible result codes:
\begin{description}
	\ttitem{0x10 R\_CHALLENGE} \hfill \\
		Server challenge. Payload is a single {\tt data} field with contents of the challenge. The
		client must react by sending a client response.
	\ttitem{0x11 R\_SUCCESS} \hfill \\
		Successful outcome -- the client is now authenticated. This is an empty packet.
	\ttitem{0x12 R\_SUCCESS\_OPT} \hfill \\
		Successful outcome, with additional data from the server. The payload is a single {\tt data}
		field with the server data.
	\ttitem{0x20 E\_FAILED} \hfill \\
		Authentication failed. This may indicate that client credentials are invalid, account is
		disabled or expired, etc. The payload is either empty, or it is a {\tt data} field, containing
		UTF-8-encoded textual description of the failure.
	\ttitem{0x21 E\_BAD\_MECHANISM} \hfill \\
		Client specified an unknown mechanism
	\ttitem{0x22 E\_BAD\_MESSAGE} \hfill \\
		Client response is mangled or the mechanism doesn't understand it
	\ttitem{0xFF E\_SERVFAIL} \hfill \\
		Internal server error
\end{description}

In response to {\tt R\_CHALLENGE}, client must send a request packet with command code {\tt 0x12
SASL\_RESPONSE} and a {\tt data} payload with contents of the response.

%%

\begin{table}
\begin{center}

\def\tline#1#2{ {\ttfamily #1} & {\ttfamily #2} }
\begin{tabular}{cll}
	\hline
	Code & Symbolic name & Description \\
	\hline
	\tline{0x00}{R\_OK} & Success \\
	\tline{0x01}{R\_CONTINUED} & Directory listing continued \\
	\tline{0x02}{R\_FINISHED} & Directory listing ends \\
	\hline

	\tline{0x80}{E\_BADPACKET} & Malformed request packet \\
	\tline{0x81}{E\_BADEXTENSION} & Unsupported extension \\
	\tline{0x82}{E\_BADCOMMAND} & Unrecognized command \\
	\tline{0x83}{E\_BADHANDLE} & File handle out of range \\
	\tline{0x84}{E\_BADPATH} & Path string is not acceptable \\
	\tline{0x85}{E\_DENIED} & Access denied \\
	\tline{0x86}{E\_BUSY} & Cannot access, try again later \\
	\tline{0x87}{E\_IO} & I/O error on server \\
	\tline{0x88}{E\_NOTFOUND} & Resource does not exist \\
		~ & ~ & Path component is not a directory \\
	\tline{0x89}{E\_NOTDIR} & Directory operation attempted on non-directory \\
	\tline{0x8A}{E\_NOTFILE} & File operation attempted on directory \\
	
	\hline

	\tline{0x90}{E\_BADATTR} & Unsupported attribute code \\
	\tline{0x91}{E\_BADVALUE} & Specified attribute value is not acceptable \\

	\hline

	\tline{0xA0}{E\_BADOFFSET} & Read or write offset is not acceptable \\
	\tline{0xA1}{E\_TOOBIG} & File size limit reached \\
	\tline{0xA2}{E\_DEVFULL} & No space left on filesystem \\

	\hline

	\tline{0xB0}{E\_NOTEMPTY} & Attempting to delete a non-empty directory \\
	\tline{0xB1}{E\_BADMOVE} & Directory move would result in path loop \\
		~ & ~ & Move would overwrite a directory \\
		~ & ~ & Move would overwrite a file by a directory \\
		~ & ~ & New path component is not a directory \\
	\tline{0xB2}{E\_CROSSDEV} & Move crosses filesystem boundary \\
	\tline{0xB3}{E\_EXISTS} & Directory already exists \\
	\tline{0xB4}{E\_READDIR} & Directory is not rewound for reading \\

	\hline

	\tline{0xFD}{E\_UNSUPPORTED} & Feature or argument unsupported \\
	\tline{0xFE}{E\_FAIL} & Generic command failure \\
	\tline{0xFF}{E\_SERVFAIL} & Internal server error \\
\end{tabular}

\end{center}
\caption{Result codes}
\label{table:results}
\end{table}

%%

\section{Core commands}

This section describes each command from the core set (extension code {\tt 0x00}), its arguments, reply format
and possible result codes.  Table \ref{table:results} describes all core result codes. Codes below {\tt 0x80}
indicate success, codes {\tt 0x80} and above indicate error.

Result code {\tt R\_OK} represents generic success, which is appropriate in most cases. Unless other success
codes can be returned as well, it is not mentioned in the description.

Result codes in the range {\tt 0x80}--{\tt 0x8F} are generic and can be returned by any command. These are not
mentioned in command descriptions, unless there are special concerns.  Result codes {\tt E\_FAIL} and {\tt
E\_SERVFAIL} indicate exceptional server states that might not be recoverable. The server might close the
connection after sending these codes. Continuing communication after receiving {\tt E\_SERVFAIL} is unsafe.

Result code {\tt E\_UNSUPPORTED} indicates that the implementation understands the request, but refuses to
service it. This code can only be returned in situations where behavior is implementation-defined.

\clearpage

\subsection{ASSIGN}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x00}
	\item[Arguments:] {\tt data path}
\end{description}

Assigns a new path to a file handle. Performs checks to verify that the path string is valid according to
section \ref{ssec:paths}, and that it conforms to OS or filesystem limitations. Does not check whether the
path or any of its components actually exist in the filesystem. Specifically this means that if the path
appears to confirm to filesystem rules, but turns out to be invalid when attempting to access it, calls other
than {\tt ASSIGN} can return {\tt E\_BADPATH} at a later point.

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] none
	\item[Specific errors:] none
\end{description}

\subsection{STAT}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x01}
	\item[Arguments:] {\tt data attributes}
\end{description}

Queries information about specified filesystem object. The returned information is a list of fields in the
order specified by the {\tt attributes} argument. Each attribute may appear only once.


\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] {\it depends on arguments}
	\item[Specific errors:] \hfill \\
		\begin{tabular}{lp{10.5cm}}
			{\tt E\_BADATTR} &
				Attribute code from the list is unknown or not supported on the platform,
				or an attribute is listed more than once \\
		\end{tabular}
\end{description}

\subsection{SETATTR}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x02}
	\item[Arguments:] \hfill \\
		\begin{tabular}{lll}
			\pkfield{byte}{attribute}{}
			\pkfield{data}{value}{}
		\end{tabular}
\end{description}

Attempts to set an attribute {\tt attribute} to a new value {\tt value}. Size of {\tt value} depends on the
attribute specified.

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] none
	\item[Specific errors:] \hfill \\
		\begin{tabular}{lp{10.5cm}}
			{\tt E\_BADATTR} & Attribute code is unknown, unsupported on the platform, \newline
				or not writable. \\
			{\tt E\_BADVALUE} & Specified value cannot be set \\
		\end{tabular}
\end{description}

\subsection{STATVFS}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x03}
	\item[Arguments:] none
\end{description}

Queries filesystem information for the given path.

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] \hfill \\
		\begin{tabular}{lll}
			\pkfield{uint32}{device\_id}{Corresponds to the {\tt device\_id} attribute}
			\pkfield{uint64}{capacity}{Total filesystem size}
			\pkfield{uint64}{free\_space}{Free space available}
			\pkfield{uint8}{readonly}{{\tt 0x00} for writable filesystem, {\tt 0x01} for read-only filesystem}
		\end{tabular}
	\item[Specific errors:] none
\end{description}

\subsection{READ}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x10}
	\item[Arguments:] \hfill \\
		\begin{tabular}{lll}
			\pkfield{uint64}{offset}{}
			\pkfield{uint16}{read\_len}{}
		\end{tabular}
\end{description}

Reads {\tt read\_len} bytes from file, starting at {\tt offset}. Returns exactly {\tt read\_len} bytes of
data, unless it encounters end of file or unless an error occurs. In case of error, returns data successfully
read before the error occured. If {\tt offset} points beyond end of file, returns success and zero-length
data.

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] {\tt data data\_read}
	\item[Specific errors:] \hfill \\
		\begin{tabular}{lp{10.5cm}}
			{\tt E\_BADOFFSET} & Offset is not acceptable \\
		\end{tabular}
\end{description}

\subsection{WRITE}
\label{ssec:WRITE}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x11}
	\item[Arguments:] \hfill \\
		\begin{tabular}{lll}
			\pkfield{uint64}{offset}{}
			\pkfield{data}{write\_data}{}
		\end{tabular}
\end{description}

Length of {\tt write\_data}, calculated as remaining space in the packet, will be refered to as {\tt write\_len}.

Writes {\tt write\_len} bytes of data to a file, starting at {\tt offset}. Returns number of bytes written. On
success, this will be exactly {\tt write\_len}. On error, it might be a smaller number.

If the file does not exist, it is created. If {\tt write\_len} is zero, the server attempts to open the file
for writing but does not write any data. This can be used to create an empty file.

If the offset points beyond end of file, the command will attempt to transparently extend the file. This will
succeed if the filesystem supports sparse files. If not, the implementation can either extend the file by
appending null bytes until it reaches the offset, or return {\tt E\_UNSUPPORTED}. The implementation might
impose an arbitraty limit on how far the offset can be from the end of the file before {\tt E\_UNSUPPORTED} is
returned. If a size limit is reached or all disk space consumed while extending the file, the implementation
should return the appropriate error code and attempt to restore the file to its previous state.

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] {\tt uint16 bytes\_written}
	\item[Specific errors:] \hfill \\
		\begin{tabular}{lp{10.5cm}}
			{\tt E\_BADOFFSET} & Offset is not acceptable \\
			{\tt E\_TOOBIG} & File size reached a filesystem or operating system limit \\
			{\tt E\_DEVFULL} & No space left on device
		\end{tabular}
\end{description}

\subsection{TRUNCATE}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x12}
	\item[Arguments:] {\tt uint64 size}
\end{description}

Sets file size to specified value. If the file was larger than {\tt size}, its contents are truncated. If the
file was smaller than {\tt size}, the discussion from~\ref{ssec:WRITE} applies: essentialy, when enlarging
a small file, results of {\tt TRUNCATE} and {\tt WRITE} with zero {\tt write\_len} are the same.

Does not implicitly create the file, may return {\tt E\_NOTFOUND} if the file does not exist.

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] none
	\item[Specific errors:] \hfill \\
		\begin{tabular}{lp{10.5cm}}
			{\tt E\_BADOFFSET} & Offset is not acceptable \\
			{\tt E\_TOOBIG} & File size reached a filesystem or operating system limit \\
			{\tt E\_DEVFULL} & No space left on device
		\end{tabular}
\end{description}

\subsection{DELETE}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x20}
	\item[Arguments:] none
\end{description}

Deletes a file or an empty directory.

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] none
	\item[Specific errors:] \hfill \\
		\begin{tabular}{lp{10.5cm}}
			{\tt E\_NOTEMPTY} & Attempting to delete a non-empty directory \\
		\end{tabular}
\end{description}

\subsection{RENAME}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x21}
	\item[Arguments:] {\tt data newpath}
\end{description}

Renames or moves a filesystem object so that its new path is {\tt newpath}. The new path must be in the same
filesystem tree. If moving a directory, the new path must not be inside the directory.

If the new path exists and is a file, and the file handle also points to a file, the file at {\tt newpath} is
overwritten.

If the operation succeeds, the file handle is updated with the new path.

Result data: none

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] none
	\item[Specific errors:] \hfill \\
		\begin{tabular}{lp{10.5cm}}
			{\tt E\_BADPATH} & File handle path or the new path is not acceptable \\
			{\tt E\_BADMOVE} & Moving directory into itself, or new path exists but one of the
				paths is not a file \\
			{\tt E\_CROSSDEV} & Move would cross filesystem boundaries \\
		\end{tabular}
\end{description}

\subsection{MAKEDIR}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x22}
	\item[Arguments:] none
\end{description}

Creates a directory. Fails if the directory already exists.

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] none
	\item[Specific errors:] \hfill \\
		\begin{tabular}{lp{10.5cm}}
			{\tt E\_EXIST} & Directory already exists \\
		\end{tabular}
\end{description}

\subsection{REWINDDIR}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x30}
	\item[Arguments:] none
\end{description}

Prepares directory for reading.

At session initialization, server informs the client of how many directories can be in the state ``prepared
for reading'' at any given time. This will usually be less than 10, some implementations may only allow one.
When {\tt REWINDDIR} is called on more directories than that, the first one loses the ``prepared for reading''
status in favor of the last one, etc. It is recommended that the client always completes directory listing of
one directory before moving on to another.

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] none
	\item[Specific errors:] none
\end{description}

\subsection{READDIR}

\begin{description}[noitemsep,topsep=1pt]
	\item[Code:] {\tt 0x31}
	\item[Arguments:] {\tt data attributes}
\end{description}

Reads as many directory entries as possible and returns them as names and the specified set of attributes.
Each attribute may be specified only once. Does not return {\tt R\_OK}: returns either {\tt R\_CONTINUED} if
there are more items to be read, or {\tt R\_FINISHED} if no items remain. Every success packet, including the
final {\tt R\_FINISHED}, contains at least one directory entry.

Each entry is stored in the following format:
\beginpk
	\pkfield{string}{name}{}
	\pkfield{string}{attributes}{}
\endpk

If the command is interrupted by an error, result data will still contain the entries that were successfully
read. It is undefined whether ``prepared for reading'' state is lost on error.

To obtain full directory listing, client must first call {\tt REWINDDIR} and then repeat calling {\tt
READDIR} until it encounters {\tt R\_FINISHED} result code. At that point, ``prepared for reading'' state is
lost and subsequent reads will return {\tt E\_READDIR}.

\begin{description}[noitemsep,topsep=1pt]
	\item[Result data:] \hfill \\
		\begin{tabular}{lll}
			\pkfield{uint16}{num\_entries}{Number of entries}
			\pkfield{data}{entries}{Sequence of entries}
		\end{tabular}
	\item[Specific errors:] \hfill \\
		\begin{tabular}{lp{10.5cm}}
			{\tt E\_BADATTR} & Attribute code from the list is unknown or not supported on the platform \\
			{\tt E\_READDIR} & Directory is not prepared for reading \\
		\end{tabular}
\end{description}

%%

\section{Links extension}

{\bf Name:} {\tt links} \\
{\bf Extension code:} {\tt 0x01 EXT\_LINKS}

This extension provides commands for manipulating symbolic links and hard links. When present, a new
attribute is added 

This extension allows creation of symlinks and hard links. It implements three commands: make symlink, make
hardlink, lstat. It adds a new attribute code: type-or-symlink, which copies ATTR\_TYPE but shows symlinks.

\subsection{Asynchronous operations}

TODO

This extension copies all core commands, and introduces COPY. Also, RENAME can move cross-filesystem, and
DELETE can (when specified) delete recursively The scheme is the same for all of them: instead
of actual result, it starts a long-running operation and returns operation-started. Another command, PROGRESS, on
the same file handle, can query status of this operation, and reports the progress, and if the operation is
finished. The operation RESULT will return NOTFINISHED, or the actual result of the operation.
The operation ABORT will abort an operation in progress.

You must not run other operations on the handle. If you reassign the handle, the long-running operation is
silently aborted. This can have unexpected results, such as half-copied directory structure.

\subsection{Extended attributes}

TODO

Commands: LISTXATTR, GETXATTR, SETXATTR, REMOVEXATTR. New attribute showing number of extended attributes on a file.

\subsection{Replay}

Command: SESSION  - gives back a 64bit session token, and a size of buffer
Command: REPLAY(token) - returns *only headers* for last N non-idempotent operations under this token. Kills other session,
reassociates with the token.
the operations affected are: RENAME, DELETE, MAKEDIR (others?)
